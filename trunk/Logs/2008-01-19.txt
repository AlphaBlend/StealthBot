 [10:26:37 AM] -> Welcome to StealthBot Beta v2.6999, by Stealth.
 [10:26:37 AM] -> If you enjoy StealthBot, consider supporting its development at http://support.stealthbot.net
 [10:26:37 AM]  [10:26:37 AM] 'ccx
'1.32
'&Custom Command Xystem:Snap (SnapWilliam@Gmail.com)


'//Written By Snap
'//   Special Thanks:
'//DragoonHybrid99
'//Ribose
'//Jack
'//DeadlyWorkz
'//Ronin


' 2.6R3 and 2.6994 Compatible

 
'//The relatively ordinary "Do Not Edit Below" Line
'// Seriously though guys, don't edit this script, it's a highly evolving script right now.
'//  If you want to make a change, why not ask me - I might wish to implement it!
'-------------------------------


'//Leave this outside Event_Load - so that it executes before the other plugin's event_load's run.
'//This way they can register functions.
Public ccx
Set ccx = New ccxClass


Public BENCHMARK
'//Benchmark the CC's to test improvments.
Public Const DoBench = False


Sub ccx_Event_Load()

   '//See Class Initialize.
   '// Disable Built-In Commands.
   If GetBotVersion = "StealthBot v2.6" Then
      WriteConfigEntry "Numeric", "cmdadd", "1000", "access.ini"
      WriteConfigEntry "Numeric", "cmddel", "1000", "access.ini"
      WriteConfigEntry "Numeric", "cmdlist", "1000", "access.ini"
   End If
   
   If ccx.FSO.FileExists(BotPath() & "commands.dat") Then
      Convert BotPath() & "commands.dat", BotPath() & "BackupCmds.dat"
   End If
End Sub

Sub Convert(FileName, FileTo)
   '//Create the ADODB Stream
   Dim Binary, Data
   Set Binary = CreateObject("ADODB.Stream")
   Binary.Type = 2
   Binary.CharSet = "iso-8859-1"
   
   '//Open the file
   Binary.Open
   Binary.LoadFromFile FileName
   Data = Binary.ReadText
   Binary.Close
   
   If Len(Data) < 20 Then Exit Sub
   
   Addchat VBwhite, "CCX: Converting commands..."
   
   Dim Tmp, Access, Command, Response, Pointer, IntS, IntA
   '//Commands Added/Skiped
   IntA = 0 : IntS = 0
   '//Pointer holds the position where were looping.
   Pointer = 1
   '//Now to parse those commands.
   Do
      '//Access is first.
      '//Get the access in Binary
      Tmp = Mid(Data, Pointer, 2)
      '//Convert the Binary value
      Access = Eval("&H" & Hex(Asc(Right(Tmp, 1))) & Hex(Asc(Left(Tmp, 1))))
      '//Move along, move along
      Pointer = Pointer + 2
      
      '//This one is easy!
      Command = Trim(Mid(Data, Pointer, 20))
      Pointer = Pointer + 20
      '//Trim from the right, we want to save the spaces infront :).
      Response = RTrim(Mid(Data, Pointer, 500))
      '//Ya, I'm confused about it being one short of 500 too.
      Pointer = Pointer + 499
      '//Verify, and append the list.
      If Right(Command, 1) <> Chr(0) AND Len(Command) > 0 Then
         'SP = SP  & VBNewLine & Command & "*" & Access & "***" & Response
         If Not ccx.CC.Exists(Command) Then
            ccx.SaveCommand Command, Access, "", "", Response
            IntA = IntA + 1
         Else
            IntS = IntS + 1
         End If
      End If
   Loop Until Pointer > Len(Data)
   Addchat VByellow, "CCX: " & IntA & " commands have been successfully added. " & IntS & " command duplicates were skiped."
   '//Move the file
   Addchat VBwhite, "CCX: Backing up old commands file..."
   If ccx.FSO.FileExists(FileName & ".old") Then ccx.FSO.DeleteFile(FileName & ".old")
   ccx.FSO.MoveFile FileName, FileName & ".old"
   '//Create a blank file for 2.6 issues
   If GetBotVersion = "StealthBot v2.6" Then ccx.FSO.CreateTextFile(FileName)
   'ccx.FSO.CreateTextFile(FileName)
   Addchat VBwhite, "CCX: Commands have been converted to CCX"
End Sub



Sub ccx_Event_UserTalk(Username, Flags, Message, Ping)
   ccx_ProcessInput Username, Message, "Talk", Flags, Ping
End Sub

Sub ccx_Event_WhisperFromUser(Username, Flags, Message)
   ccx_ProcessInput Username, Message, "Whisper", Flags, 0
End Sub
 
Sub ccx_Event_PressedEnter(Text)
 
   If Left(Text, 4) = "/cc " Then
      VetoThisMessage
      AddQ ccx.ParseFunctions(Mid(Text, 5))
   End If

   If Left(Text, 2) = "//" Then
      ccx_ProcessInput Botvars.username, Mid(Text, 2), "UEnter", "", 0
      Exit Sub
   End If
   If Left(Text, 1) = "/" Then ccx_ProcessInput Botvars.username, Text, "Enter", "", 0
End Sub
 
 
'For ProcessInput
Sub ccx_R(Username, Message, Method)
 
   Select Case Method
      Case "Enter"
         AddChat vbCyan, Message
         'VetoThisMessage
         '//Double // commands.
      Case "UEnter"
         Dsp 1, Message, 0, 0
         'VetoThisMessage
      Case "Talk"
         Dsp 1, Message, 0, 0
      Case "Whisper"
         Dsp 3, Message, Username, 0
   End Select
 If DoBench = True Then Addchat VBwhite, GetGTC - BENCHMARK
End Sub

Public Function ccx_CommandAccess(Command)

   Dim Access, Tmp
   '//Built-In commands.
   Select Case Command
      Case "cclist", "listcc", "cmdlist"
         Access = 20
      Case "findcc", "findcmd"
         Access = 20
      Case "addcc", "addcmd", "cmdadd"
         Access = 100
      Case "delcc", "delcmd", "cmddel"
         Access = 100
      Case "renamecc", "renamecmd"
         Access = 90
      Case "showcc", "showcmd"
         Access = 80
      Case "testcc", "testcmd"
         Access = 100
      Case "reloadcc", "reloadcmd"
         Access = 100
      Case "setcc", "setcmd"
         Access = 100
      Case "editcc", "editcmd"
         Access = 100
      Case "clipcc", "clipcmd"
         Access = 100
      Case Default = 0
   End Select
   Tmp = GetConfigEntry("numeric", Command, "access.ini")
   If IsNumeric(Tmp) Then Access = Tmp
   
   ccx_CommandAccess = Access
End Function

 
Sub ccx_ProcessInput(Username, Message, Source, Flags, Ping)

   If Message = Botvars.trigger OR Message = "/" Then Exit Sub
   
   If DoBench = True Then BENCHMARK = GetGTC
   
   Dim Cmd
   If Left(Message, Len(Botvars.trigger)) = BotVars.Trigger Then
      Cmd = LCase(Split(Mid(Message, Len(Botvars.trigger) + 1))(0))
   ElseIf Left(Message, 1) = "/" Then
      Cmd = LCase(Split(Mid(Message, 2))(0))
   Else
      Exit Sub
   End If
   
   Dim RStr, RAry, Tmp, Tmp2, InBot, I
   
   RStr = Trim(Split(Message & " ", " ", 2)(1))
 
   GetDBEntry Username, UAccess, UFlags
   If Source = "Enter" OR Source = "UEnter" Then
      UAccess = 1000
      InBot = True
   End If
   
   If NOT (ccx_CommandAccess(Cmd) > UAccess) Then
      '//Built-In commands.
      Select Case Cmd
         Case "cclist", "listcc", "cmdlist"
            If InBot Then VetoThisMessage
            ccx_R Username, "Commands that you can use: " & ccx.FindCommands("", UAccess, UFlags), Source
         Case "findcmd", "findcc"
            If InBot Then VetoThisMessage
            Tmp = ccx.FindCommands(RStr, UAccess, UFlags)
            If Tmp <> "" Then
               ccx_R Username, "Matching commands (that you can use): " & Tmp, Source
            Else
               ccx_R Username, "No commands found. Example: " & Botvars.Trigger & "findcc note", Source
            End If
               
         Case "addcc", "addcmd", "cmdadd"
            If InBot Then VetoThisMessage
            RAry = Split(RStr, " ", 3)
    
            If UBound(RAry) <> 2 Then
               'Addchat VBwhite, "Command format: !addcc (name) (access)[/flags] (response)"
               ccx_R Username, "Example: !addcc givetea 20 /me gives %1 tea. Compliments of %user", Source
               Exit Sub
            End If
            Dim T_Flags, T_Access, T_Name
            If Isnumeric(RAry(1)) Then
               T_Access = RAry(1)
            Else
               If InStr(RAry(1), "/") Then
                  Tmp = Split(RAry(1), "/")
                  T_Access = Tmp(0)
                  If Not IsNumeric(Tmp(0)) AND Tmp(0) <> "" Then
                     ccx_R Username, "Bad you, no CC for you", Source
                     '//Invalid Format
                     Exit Sub
                  End If
                  T_Flags = Tmp(1)
               Else
                  ccx_R Username, "You must supply an access amount", Source
                  Exit Sub
               End If
            End If
            '//Rename command if existing.
            If ccx.CC.Exists(RAry(0)) Then
               For I = 1 to 40
                  If Not ccx.CC.Exists(RAry(0) & I) Then
                     T_Name = RAry(0) & I
                     ccx_R Username, "Command name was already taken - name changed to: " & T_Name & " You can use !renamecc to change it", Source
                     Exit For
                  End If
               Next
            Else
               T_Name = RAry(0)
            End If
    
            ccx.SaveCommand T_Name, T_Access, T_Flags, "", RAry(2)
            If T_Access = "" Then T_Access = "no"
            If T_Flags = "" Then T_Flags = "no"
            ccx_R Username, "Command """ & T_Name & """ [" & T_Access & " access/" & T_Flags & " flags] added.", Source
         Case "delcc", "delcmd", "cmddel"
            If InBot Then VetoThisMessage
            If ccx.CC.Exists(LCase(Rstr)) Then
               ccx.DeleteCommand Rstr
               ccx_R Username, "Command """ & Rstr & """ deleted.", Source
            Else
               ccx_R Username, "Command """ & Rstr & """ wasn't found.", Source
            End If
         Case "renamecc", "renamecmd"
            If InBot Then VetoThisMessage
            RAry = Split(RStr, " ")
            If UBound(RAry) <> 1 Then
               ccx_R Username, "Format: " & Botvars.trigger & "renamecc (command) (newname)", Source
               Exit Sub
            End If
            If Not ccx.CC.Exists(LCase(RAry(0))) Then
               ccx_R Username, "Command not found: " & RAry(0), Source
               Exit Sub
            End If
            If ccx.CC.Exists(LCase(RAry(1))) Then
               ccx_R Username, "Command already named: " & RAry(1), Source
               Exit Sub
            End If
    
            ccx.SaveCommand LCase(RAry(1)), ccx.CC.Item(RAry(0)).access, ccx.CC.Item(RAry(0)).flags, ccx.CC.Item(RAry(0)).trigger, ccx.CC.Item(RAry(0)).response
            ccx.DeleteCommand RAry(0)
            ccx_R Username, "Command renamed: " & RAry(0) & " -> " & RAry(1), Source
         Case "showcc", "showcmd"
            If InBot Then VetoThisMessage
            If RStr = "" Then
               ccx_R Username, "Please enter a command name.", Source
               Exit Sub
            End If
            If Not ccx.CC.Exists(LCase(RStr)) Then
               ccx_R Username, "Command not found: " & RStr, Source
            Else
               With ccx.CC.Item(LCase(RStr))
                  ccx_R Username, "Command [" & LCase(RStr) & "][" & .Access & "/" & .Flags & "] " & .Response, Source
               End With
            End If
         Case "testcc", "testcmd"
            If InBot Then VetoThisMessage
            ccx_R Username, ccx.ParseFunctions(RStr), Source
         Case "reloadcc", "reloadcmd"
            If InBot Then VetoThisMessage
            ccx.LoadCommands
            ccx_R Username, "Commands reloaded from text file.", Source
            
         Case "setcc", "setcmd"
            If InBot Then VetoThisMessage
            If RStr = "" Then
               ccx_R Username, "Example: " & Botvars.trigger & "setcc MyCmd 50/M ", Source
               Exit Sub
            End If
            RAry = Split(RStr, " ", 2)
            Addchat Vbyellow, RAry(1)
            If ccx.CC.Exists(RAry(0)) Then
               If IsNumeric(RAry(1)) Then
                  T_Access = RAry(1)
               Else
                  If InStr(RAry(1), "/") Then
                     Tmp = Split(RAry(1), "/")
                     T_Access = Tmp(0)
                     If Not IsNumeric(Tmp(0)) AND Tmp(0) <> "" Then
                        ccx_R Username, "Bad you, no CC for you", Source
                        '//Invalid Format
                        Exit Sub
                     End If
                     T_Flags = Tmp(1)
                  Else
                     ccx_R Username, "You must supply an access amount", Source
                     Exit Sub
                  End If
               End If
               ccx.CC.Item(RAry(0)).Access = T_Access
               ccx.CC.Item(RAry(0)).Flags = T_Flags
               ccx.SaveChanges RAry(0)
               If T_Access = "" Then T_Access = "no"
               If T_Flags = "" Then T_Flags = "no"
               ccx_R Username, "Command """ & RAry(0) & """ set: [" & T_Access & " access/" & T_Flags & " flags]", Source
            End If
            
         Case "editcc", "editcmd"
            If InBot Then VetoThisMessage
            If RStr = "" Then
               ccx_R Username, "Example: " & Botvars.trigger & "editcc MyCmd New Response", Source
               Exit Sub
            End If
            RAry = Split(RStr, " ", 2)
            Addchat Vbyellow, RAry(1)
            If ccx.CC.Exists(RAry(0)) Then
               ccx.CC.Item(RAry(0)).Response = RAry(1)
               ccx.SaveChanges RAry(0)
               ccx_R Username, "Command: " & RAry(0) & " updated", Source
            End If
            
         Case "clipcc", "clipcmd"
            If InBot Then VetoThisMessage
            If RStr = "" Then
               ccx_R Username, "Please enter a command name.", Source
               Exit Sub
            End If
            If Not ccx.CC.Exists(LCase(RStr)) Then
               ccx_R Username, "Command not found: " & RStr, Source
            Else
               With ccx.CC.Item(LCase(RStr))
                  '//Thanks DeadlyWorkz
                  Dim objHTML
                  Set objHTML = CreateObject("htmlfile")
                  objHTML.parentWindow.clipboardData.setData "text", Botvars.trigger & "addcc " & LCase(RStr) & " " & .Access & "/" & .Flags & " " & .Response '// Set clipboard text
                  ccx_R Username, "Command [" & LCase(RStr) & "] Set to (Bot-Owners) Clipboard", Source
               End With
            End If
      End Select
   End If
 
   '==Protect against inf loops w/ %runcc (Public var within the loop check if it = 30 or something)
 
   If ccx.CC.Exists(Cmd) Then
      If InStr(Source, "Enter") Then VetoThisMessage
      
      Dim strRes
      With ccx.CC.Item(Cmd)
         If ccx.HasAccess(Cmd, UAccess, UFlags) = False Then Exit Sub
      
         strRes = .Response
      End With
      
      With ccx
         '//Escape special char's so you can't use %'s within %rest.
         RStr = .AddEscape(RStr)
         Username = .AddEscape(Username)
         
         'Addchat VByellow, strRes
         '//Basic replacments
         strRes = Replace(strRes, "%user", Username)
         strRes = Replace(strRes, "%trigger", Botvars.Trigger)
         strRes = Replace(strRes, "%0", Username)
         strRes = Replace(strRes, "%chancount", GetInternalUserCount())   
         strRes = Replace(strRes, "%chan", .AddEscape(MyChannel))
         strRes = Replace(strRes, "%access", UAccess)
         strRes = Replace(strRes, "%flags", UFlags)
         strRes = Replace(strRes, "%gtc", GetGTC())
         strRes = Replace(strRes, "%time", Time)
         strRes = Replace(strRes, "%date", Date)
         strRes = Replace(strRes, "%args", UBound(Split(RStr)) + 1)
         
    
         '//Clan Bnetflags Ping Product Safelisted Statstring Timeinchan Timesincetalk User/0 chancount chan access flags gtc time date
         If InStr(strRes, "%") Then strRes = ccx_ParseGID(strRes, Username)
         
         If Instr(strRes, "%ruser") Then
            For I = 16 To 1 Step - 1
               Tmp = .AddEscape(GetNameByPosition(Int(Rnd * GetInternalUserCount()) + 1))
               If Tmp2 = Tmp AND GetInternalUserCount() > 1 Then
                  '//Try again.
                  I = I + 1
               Else
                  Tmp2 = Tmp
                  strRes = Replace(strRes, "%ruser" & I, Tmp)
               End If
            Next
            strRes = Replace(strRes, "%ruser", Tmp)
         End If
         
         '//Parse the args - like %1, %2 %all etc.
         If InStr(strRes, "%") Then strRes = .ParseArgs(strRes, RStr)
         '//Parse all the functions.
         If InStr(strRes, "%") Then strRes = .ParseFunctions(strRes)
         If Source = "Enter" Then VetoThisMessage
         '// Bring back special chars to the response were sending.
         StrRes = .RemoveEscape(strRes)
         If InStr(StrRes, "& ") Then
            For Each Item In Split(strRes, "& ")
               '//This should be processed for /
               ccx_R Username, Item, Source
            Next
         Else
            ccx_R Username, StrRes, Source
         End If
      End With
   End If
End Sub


Public Function ccx_ParseGID(Text, Username)
 
   Text = Replace(Text, "%clan", GetInternalDataByUsername(Username, 0))
   Text = Replace(Text, "%bnetflags", GetInternalDataByUsername(Username, 1))
   Text = Replace(Text, "%ping", GetInternalDataByUsername(Username, 2))
   Text = Replace(Text, "%product", GetInternalDataByUsername(Username, 3))
   Text = Replace(Text, "%safelisted", GetInternalDataByUsername(Username, 4))
   Text = Replace(Text, "%statstring", GetInternalDataByUsername(Username, 5))
   Text = Replace(Text, "%timeinchan", GetInternalDataByUsername(Username, 6))
   Text = Replace(Text, "%timesincetalk", GetInternalDataByUsername(Username, 7))
   ccx_ParseGID = Text
End Function


'//Written By Zergmaster
Function CheckAccessFlags(Username, ReqA, ReqF)
    Dim UsrA, UsrF, i, ThisF
    CheckAccessFlags = False
    If LCase(Username) = "(console)" Or LCase(Username) = LCase(BotVars.Username) Or LCase(Username) = LCase(myUsername) Then
        CheckAccessFlags = True
        Exit Function
    End If
    On Error Resume Next
    If LCase(Username) = LCase(BotVars.BotOwner) Then
        CheckAccessFlags = True
        Exit Function
    End If
    Err.Clear()
    GetDBEntry Username, UsrA, UsrF
        If IsNumeric(ReqA) Then
               If ReqA > UsrA Then Exit Function
        End If
    If Len(ReqF) = 0 Then
        CheckAccessFlags = True
        Exit Function
    End If
    For i = 1 To Len(ReqF)
        ThisF = Mid(ReqF, i, 1)
        If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", UCase(ThisF)) Then
            If Not InStr(UCase(UsrF), UCase(ThisF)) Then Exit Function
        End If
    Next
    CheckAccessFlags = True
End Function


Class ccxCC
 
   Public Access, Flags, Response, Trigger
End Class


Class ccxClass
 
   Public CC
   Public FuncList
   Public FSO
   Public DL_Path
   Public CC_Path
   Private PendCC
   
   '//Return solution
   Public ReturnSol
   
   '//Anti Loop I. - Used for preventing an infinite loop.
   Private AntIloop
 
   Private Sub Class_Initialize()
 
      Set Me.FuncList = CreateObject("Scripting.Dictionary")
      Set Me.CC = CreateObject("Scripting.Dictionary")
      Me.CC.CompareMode = 1
      Me.FuncList.CompareMode = 1
      
      Set Me.FSO = CreateObject("Scripting.FileSystemObject")
      Me.DL_Path = ".\Plugins\ccx_DL.txt"
      Me.CC_Path = ".\Plugins\ccx_CC.txt"
      Me.LoadCommands
   End Sub
 
 
   Sub LoadCommands()
 
      Dim File, arrCmd
      Set File = Me.FSO.OpenTextFile(Me.CC_Path, 1, True)
      '//Clear first.
      Me.CC.RemoveAll
      Do While Not File.AtEndOfStream
         arrCmd = Split(File.ReadLine, "*", 2)
         If UBound(arrCmd) = 1 Then
            Dim StrName, ArrData
            StrName = LCase(arrCmd(0))
            ArrData = Split(arrCmd(1), "*", 4)
            Set Me.CC.Item(StrName) = New ccxCC
            Me.CC.Item(StrName).Access = ArrData(0)
            Me.CC.Item(StrName).Flags = ArrData(1)
            Me.CC.Item(StrName).Trigger = ArrData(2)
            Me.CC.Item(StrName).Response = ArrData(3)
         End If
      Loop
   End Sub

   Public Sub SaveCommand(Name, Access, Flags, Trigger, Response)
 
      Dim File, strCmd
      Set file = Me.FSO.OpenTextFile(Me.CC_Path, 8, True)
      File.Write VBNewLine & Name & "*" & Access & "*" & Flags & "*" & Trigger & "*" & Response
      'Me.CC.Add LCase(Name), Array(Access, Flags, Trigger, Command)
      Set Me.CC.Item(Name) = New ccxCC
      Me.CC.Item(Name).Access = Access
      Me.CC.Item(Name).Flags = Flags
      Me.CC.Item(Name).Trigger = Trigger
      Me.CC.Item(Name).Response = Response
   End Sub
   
   Public Sub DeleteCommand(Name)

      Name = LCase(Name)
      Dim File, Tmp
      '//Read File
      Set File = Me.FSO.OpenTextFile(Me.CC_Path, 1, True)
      If File.AtEndOfStream Then Exit Sub
      Tmp = File.Readall
      '//Write modified file
      Set File = Me.FSO.OpenTextFile(Me.CC_Path, 2, True)
      Tmp = Split(Tmp, vbNewLine)
      For Each Line In Tmp
         If (LCase(Split(Line & "*", "*")(0)) <> Name) AND Line <> "" Then
            File.Write VBNewLine & Line
         End If
      Next
      '//Remove from dictionary.
      Me.CC.Remove Name
   End Sub
 
 
   Public Sub SaveChanges(Name)
   
      '//Mostly just copy the DeleteCommand Sub
      Name = LCase(Name)
      Dim File, Tmp
      '//Read File
      Set File = Me.FSO.OpenTextFile(Me.CC_Path, 1, True)
      If File.AtEndOfStream Then Exit Sub
      Tmp = File.Readall
      '//Write modified file
      Set File = Me.FSO.OpenTextFile(Me.CC_Path, 2, True)
      Tmp = Split(Tmp, vbNewLine)
      For Each Line In Tmp
         If Line <> "" Then
            If (LCase(Split(Line & "*", "*")(0)) <> Name) Then
               File.Write VBNewLine & Line
            Else
               With Me.CC.Item(Name)
                  File.Write VBNewLine & Name & "*" & .Access & "*" & .Flags & "*" & .Trigger & "*" & .Response
               End With
            End If
         End If
      Next
   End Sub
   
 
   '//REPLACE FUNCTIONS
   '//Replaces Arguements
   '++Bench = 0ms
   Public Function ParseArgs(Command, Input) 'as string
 
      '//%1 %2 infinite.
      Dim strRes, I, Rest, RestB
      TextAry = Split(Input)
      strRes = Command
      For I = UBound(TextAry) to 0 Step - 1
         If InStr(strRes, "%" & I + 1) Then
            RestB = True
            Rest = Mid(Rest, 2)
            strRes = Replace(strRes, "%" & I + 1, TextAry(I))
         ElseIf Not RestB Then
            Rest = " " & TextAry(I) & Rest
         End If
      Next
      For I = UBound(TextAry) + 1 to 1 Step - 1
         strRes = Replace(strRes, "%all" & I, Split(Input, " ", I)(I - 1))
      Next
      strRes = Replace(strRes, "%all", Input)
      strRes = Replace(strRes, "%rest", Trim(Rest))
      ParseArgs = strRes
 
      '== Now loop through and remove any leftover %3's that may have been left.
      '== Consider replacing with %die, or stoping here.
   End Function
   
   Public Function AddEscape(Text) 'as string
   
      Text = Replace(Text, "%", Chr(240) & Chr(239))
      Text = Replace(Text, ",", Chr(240) & Chr(238))
      Text = Replace(Text, "(", Chr(240) & Chr(242))
      Text = Replace(Text, ")", Chr(240) & Chr(243))
      AddEscape = Text
   End Function
   
   Public Function RemoveEscape(Text) 'as string
   
      Text = Replace(Text, Chr(240) & Chr(239), "%")
      Text = Replace(Text, Chr(240) & Chr(238), ",")
      Text = Replace(Text, Chr(240) & Chr(242), "(")
      Text = Replace(Text, Chr(240) & Chr(243), ")")
      RemoveEscape = Text
   End Function
   
   Public Sub ResetAntIloop()
   
      AntIloop = 0
   End Sub
 
   '//Solves/replaces all functions. (aka Step 2-4)
   Public Function ParseFunctions(Text) 'as string
 
      '//Addchat VBwhite, "ParseFunctions Start"
      Dim NLoc, RLoc, ALoc
      Dim Priority
      RLoc = Len(Text)
      '//Goes through the command finding functions
      Priority = 1
      Do
         '//This will prevent CallCC loops, and other infinite loops. - AntiLoop is reset via Sub ResetAntILoop
         If AntIloop > 2000 Then
            Exit Function
         Else
            AntIloop = AntIloop + 1
         End If
         
         NLoc = InstrRev(Mid(Text, 1, RLoc), "%")
         If NLoc = 0 Then
            '//If Priority = 2 Then Exit Do
            If Priority = 1 Then
               '//Die
               If InStr(Text, "%die(") Then
                  NLoc = InStr(Text, "%die(")
               Else
                  NLoc = InstrRev(Text, "%")
                  If NLoc = 0 Then Exit Do
               End If
               '//Prevents things like %runcc from executing if %die is still around.
               Priority = 2
            Else
               Exit Do
            End If
         End If
         
         'If NLoc = 0 AND Instr(Text, "%") = 0 Then Exit Do
         
         Deep = me.IsFunction(Mid(Text, Nloc), Priority)
         ALoc = InStr(Mid(Text, NLoc + Deep), ")")
         REM If ALoc > InStr(Mid(Text, NLoc + Deep + 1), "(") Then
            REM Addchat VBred, Mid(Text, NLoc + Deep)
            REM Addchat VBwhite, "ello" & ALoc
            REM Addchat VByellow, "ello" & Instr(ALoc, Mid(Text, NLoc + Deep + 1), ")")
         REM End If
         '//Check %die
         If Priority = 2 AND Lcase(Mid(Text, Nloc, 4)) = "%die" Then
            ParseFunctions = Me.SolveFunction(Mid(Text, NLoc, Deep), Mid(Text, NLoc + Deep + 1, ALoc - 2))
            Exit Function
         End If
         
         If Deep AND ALoc <> 0 Then
            Dim Part1, Part2, Part3
            'the bird %jumped(over) the cat
            '//Create new text
            'the bird
            Part1 = Mid(Text, 1, NLoc - 1)
            '%jumped(over) -> Over Jumped!
            Part2 = Me.SolveFunction(Mid(Text, NLoc, Deep), Mid(Text, NLoc + Deep + 1, ALoc - 2))
            ' the cat
            Part3 = Mid(Text, NLoc + Deep + Aloc)
            Text = Part1 & Part2 & Part3
         Else
            RLoc = NLoc - 1
         End If
      Loop
      
      ParseFunctions = Text
      'Addchat VByellow, "End ParseFunctions - " & ParseFunctions
   End Function

   Public Function SolveFunction(Name, Args) 'as string
 
      'Addchat VByellow, "Solve Function start: " & Name
      
      Dim RStr
      Dim Tmp, Tmp2, I
      
      RStr = Args
      Args = Split(Args, ",")
      SolveFunction = ""
      '//Ignore the %
      Name = LCase(Mid(Name, 2))
 
      '//Built-In functions.
      Select Case Name
         Case "round" If UBound(Args) = 1 Then SolveFunction = Round(Args(0), Args(1))
         '//So powerful, so small...
         Case "if"
            If Me.SecureEval(Args(0)) <> False Then
               SolveFunction = Args(1)
            Else
               If UBound(Args) = 2 Then
                  SolveFunction = Args(2)
               Else
                  SolveFunction = ""
               End If
            End If
         Case "ifnot"
            If Me.SecureEval(Args(0)) <> True Then
               SolveFunction = Args(1)
            Else
               If UBound(Args) = 2 Then
                  SolveFunction = Args(2)
               Else
                  SolveFunction = ""
               End If
            End If
         '//Switch can come in handy!
         Case "switch"
            If UBound(Args) > 1 Then
               Tmp = Lcase(Me.SecureEval(Args(0)))
               For I = 1 to UBound(Args) Step 2
                  If Lcase(Me.SecureEval(Args(I))) = Tmp OR Lcase(Me.SecureEval(Args(I))) = "else" Then
                     SolveFunction = Args(I+1)
                     Exit Function
                  End If
               Next
            End If
         '//A loop? No wai!
         Case "for"
            If UBound(Args) > 1 Then
               If Isnumeric(Args(0)) AND Isnumeric(Args(1)) Then
                  Tmp2 = "%i"
                  If UBound(Args) = 3 Then Tmp2 = Args(3)
                  Tmp = 0
                  For I = Int(Args(0)) To Int(Args(1))
                     SolveFunction = SolveFunction & Replace(Args(2), Tmp2, I)
                     Tmp = Tmp + 1
                     If Tmp > 50 Then
                        SolveFunction = ""
                        Addchat VBred, "CC Error: %for loop cut off due to Loop MAX"
                     End If
                  Next
               End If
            End If
         '//Gota have this.
         Case "rand"
            If UBound(Args) = 1 Then
               Randomize
               SolveFunction = Int(Rnd * ((Args(1) + 1) - Args(0)) + Args(0))
            End If
         '//I'd rather make a mimic of PHP's StrSt function.
         Case "mid"
            If UBound(Args) = 2 Then
               SolveFunction = Mid(Args(0), Args(1), Args(2))
            ElseIf UBound(Args) = 1 Then
               SolveFunction = Mid(Args(0), Args(1))
            End If
         Case "item"
            If UBound(Args) = 1 Then
               Tmp = Split(Args(0))
               If UBound(Tmp) >= Int(Args(1)) - 1 Then SolveFunction = Tmp(Int(Args(1)) - 1)
            ElseIf UBound(Args) = 2 Then
               Tmp = Split(Args(0), Args(2))
               If UBound(Tmp) >= Int(Args(1)) - 1 Then SolveFunction = Tmp(Int(Args(1)) - 1)
            End If
         
         '//Returns everything except the item selected.
         Case "xitem"
            If UBound(Args) = 1 Then
               Tmp = Split(Args(0)) '//Space default
               If UBound(Tmp) >= Int(Args(1)) - 1 Then
                  Tmp(Int(Args(1)) - 1) = Chr(186) & "BURN"
                  Tmp = Filter(Tmp, Chr(186) & "BURN", False)
                  SolveFunction = Join(Tmp) '//Space default
                  Exit Function
               End If
            ElseIf UBound(Args) = 2 Then
               Tmp = Split(Args(0), Args(2))
               If UBound(Tmp) >= Int(Args(1)) - 1 Then
                  Tmp(Int(Args(1)) - 1) = Chr(186) & "BURN"
                  Tmp = Filter(Tmp, Chr(186) & "BURN", False)
                  SolveFunction = Join(Tmp, Args(2))
                  Exit Function
               End If
            End If
            
         Case "do"
            Tmp = Args(0)
            Tmp = Replace(Tmp, "@", "%")
            Tmp = Replace(Tmp, "[", "(")
            Tmp = Replace(Tmp, "]", ")")
            Tmp = Replace(Tmp, ":", ",")
            SolveFunction = Me.ParseFunctions(Tmp)
         '//Returns the amount a string appears in a string.
         Case "count"
            If UBound(Args) = 1 Then
               SolveFunction = UBound(Split(Args(0), Args(1)))
               If SolveFunction = -1 Then SolveFunction = 0
            End If
         '//Mimic function
         Case "instr"
            If UBound(Args) = 2 Then
               SolveFunction = InStr(Args(0), Args(1), Args(2))
            ElseIf UBound(Args) = 1 Then
               SolveFunction = InStr(Args(0), Args(1))
            End If
         Case "chr" If UBound(args) = 0 Then SolveFunction = Chr(Me.SecureEval(Args(0)))
         Case "math" If UBound(args) = 0 Then SolveFunction = Me.SecureEval(Args(0))
         '//Removes @lordaeron @useast #2 etc.
         Case "no@"
            Dim PUser
            PUser = Args(0)
            If Left(PUser, 1) = "*" Then PUser = Mid(PUser, 2)
            If InStr(PUser, "#") Then PUser = Mid(PUser, 1, InStr(PUser & "#", "#")-1)
            If InStr(PUser, "@") Then PUser = Mid(PUser, 1, InStr(PUser & "@", "@")-1)
            SolveFunction = PUser
         Case "getgid" '//MIMICS STEALTHBOT'S GetInternalDataByUsername
            If UBound(Args) = 1 Then
               SolveFunction = GetInternalDataByUsername(Args(0), Args(1))
            End If   
         Case "die" '// DIE
            SolveFunction = RStr
         Case "seco" '// FROM TIME IN SECONDS
            SolveFunction = me.SecondsToOrgin(Args(0))
         Case "secf" '// FROM TIME IN SECONDS
            SolveFunction = me.SecondsToTime(Args(0))
         Case "gethttp" '// URL,[SHOW RESPONSE] = True,[CATCH]=False
            'If UBound(Args) >= 1 Then
            If scinet.StillExecuting Then
               SolveFunction = "Error"
            End If
            Tmp = scinet.GetURL(Args(0))
            If Len(Tmp < 255) Then
               SolveFunction = Tmp
            Else
               SolveFunction = "Error"
            End If
         
         '//LIST FUNCTIONS
         Case "listadd"
            If UBound(Args) >= 1 Then
               Tmp = GetConfigEntry("lists", Me.SecureEval(Args(0)), Me.DL_Path)
               Tmp2 = Replace(Me.SecureEval(Args(1)), "*", "|ASTRIX|")
               WriteConfigEntry "lists", Me.SecureEval(Args(0)), Tmp & "*" & Tmp2, Me.DL_Path
            End If
            If UBound(Args) = 2 Then
               If Lcase(Args(2)) = "true" Then SolveFunction = UBound(Split(Tmp & "*", "*"))
            Else
               SolveFunction = ""
            End If
         Case "listdel"
            If UBound(Args) >= 1 Then
               Tmp = Split(GetConfigEntry("lists", Me.SecureEval(Args(0)), Me.DL_Path), "*")
               If UBound(Tmp) >= Int(Args(1)) AND Int(Args(1)) > 0 Then
                  Tmp(Int(Args(1))) = Chr(186) & "BURN"
                  Tmp = Filter(Tmp, Chr(186) & "BURN", False)
                  WriteConfigEntry "lists", Me.SecureEval(Args(0)), Join(Tmp, "*"), Me.DL_Path
                  Exit Function
               End If
            End If
         Case "listclear"
            WriteConfigEntry "lists", Me.SecureEval(Args(0)), "", Me.DL_Path
         Case "inlist"
            If UBound(Args) > 0 Then
               Tmp = Split(GetConfigEntry("lists", Me.SecureEval(Args(0)), Me.DL_Path), "*")
               SolveFunction = 0
               For I = 0 To UBound(Tmp)
                  If Lcase(Args(1)) = Lcase(Tmp(I)) Then
                     SolveFunction = I
                     Exit For
                  End If
               Next
            End If
         Case "listout"
            Tmp2 = " ##: "
            If UBound(Args) > 0 Then
               Tmp2 = Args(1)
            End If
            I = 0
            For Each Item in Split(GetConfigEntry("lists", Me.SecureEval(Args(0)), Me.DL_Path), "*")
               If Item <> "" Then
                  I = I + 1
                  If Tmp = "" And Instr(Tmp2, "#") = 0 Then
                     Tmp = Item
                  Else
                     Dim Seperator
                     'Addchat VByellow, Seperator & "||" & I
                     Seperator = Replace(Tmp2, "##", I)
                     Seperator = Replace(Seperator, "#R", me.Roman(I))
                     Seperator = Replace(Seperator, "#A", me.Alpha(I))
                     Tmp = Tmp & Seperator & Item
                  End If
               End If
            Next
            Tmp = Replace(LTrim(Tmp), "|ASTRIX|", "*")
            SolveFunction = Tmp
            
         Case "listitem"
            If UBound(Args) >= 1 Then
               Tmp = Split(GetConfigEntry("lists", Me.SecureEval(Args(0)), Me.DL_Path), "*")
               If UBound(Tmp) >= Int(Args(1)) Then SolveFunction = Tmp(Int(Args(1)))
            End If
         Case "getdef"
            SolveFunction = GetConfigEntry("def", Me.SecureEval(Args(0)), BotPath & "definitions.ini")
         Case "setdef"
            If UBound(Args) = 1 Then
               WriteConfigEntry "def", Me.SecureEval(Args(0)), Me.SecureEval(Args(1)), BotPath & "definitions.ini"
            End If
         Case "var", "getdl"
            If UBound(Args) = 0 Then
               SolveFunction = GetConfigEntry("main", Me.SecureEval(Args(0)), Me.DL_Path)
            ElseIf UBound(Args) = 1 Then
               SolveFunction = GetConfigEntry(Me.SecureEval(Args(1)), Me.SecureEval(Args(0)), Me.DL_Path)
            End If
         Case "setvar", "setdl"
            If UBound(Args) = 1 Then
               WriteConfigEntry "main", Me.SecureEval(Args(0)), Me.SecureEval(Args(1)), Me.DL_Path
            ElseIf UBound(Args) = 2 Then
               WriteConfigEntry Me.SecureEval(Args(2)), Me.SecureEval(Args(0)), Me.SecureEval(Args(1)), Me.DL_Path
            End If
         Case "withvar", "withdl" '// DLNAME, OPERATION, [RETURN RESULT] = False, [LOCATION] = main
            If UBound(Args) >= 1 Then
               Tmp = GetConfigEntry("main", Me.SecureEval(Args(0)), Me.DL_Path)
               If IsNumeric(Args(1)) Then
                  Tmp = Me.SecureEval(Tmp & "+" & Int(Args(1)))
               '//Multiply
               ElseIf IsNumeric(Replace(Args(1), "*", "")) Then
                  Tmp = Me.SecureEval(Tmp & "*" & Replace(Args(1), "*", ""))
               '//Division
               ElseIf IsNumeric(Replace(Args(1), "/", "")) Then
                  Tmp = Me.SecureEval(Tmp & "/" & Replace(Args(1), "/", ""))
               '//Power
               ElseIf IsNumeric(Replace(Args(1), "^", "")) Then
                  Tmp = Me.SecureEval(Tmp & "^" & Replace(Args(1), "^", ""))
               '//Modulo Division
               ElseIf IsNumeric(Replace(Args(1), "MOD", "")) Then
                  Tmp = Me.SecureEval(Tmp & "MOD" & Replace(Args(1), "MOD", ""))
               '//Append it
               ElseIf Left(Args(1), 1) = "&" Then
                  Tmp = Me.SecureEval(Tmp & Mid(Args(1), 2))
               ElseIf Right(Args(1), 1) = "&" Then
                  Tmp = Me.SecureEval(Mid(Args(1), 1, Len(Args(1)) - 1) & Tmp)
               '//Set it
               Else
                  Tmp = Me.SecureEval(Args(1))
               End If
            End If
            '//Write the solution.
            If UBound(Args) = 3 Then
               WriteConfigEntry Args(3), Me.SecureEval(Args(0)), Tmp, Me.DL_Path
            Else
               WriteConfigEntry "main", Me.SecureEval(Args(0)), Tmp, Me.DL_Path
            End If
            '//If true is added to the arguement.
            If UBound(Args) = 2 Then
               If Lcase(Args(2)) = "true" Then
                  SolveFunction = Tmp
               End If
            End If
            REM If Me.Datalist.Exists(Args(0)) Then
               REM Me.Datalist.Item(Args(0)) = Me.SecureEval(Args(1))
            REM Else
               REM Me.Datalist.Add Args(0), Me.SecureEval(Args(1))
            REM End If
      End Select
 
      '//Check registered functions
      If FuncList.Exists(Name) Then
         For I = 0 To FuncList.Item(Name)(1) - 1
            If UBound(Args) >= I Then
               ArgList = ArgList & ", """ & Args(I) & """"
            Else
               ArgList = ", """"" & ArgList
            End If
         Next
         'ArgList = "(" & Name & ArgList & ")"
         ArgList = "(" & Mid(ArgList, 3) & ")"
         ExecuteGlobal "ccx.ReturnSol = " & FuncList.Item(Name)(0) & ArgList
         SolveFunction = Me.ReturnSol
         Exit Function
      End If
      
         'Addchat VByellow, "Solve Function end - " & SolveFunction
   End Function
 
   '//Returns the length of the command, if it is one.
   Public Function IsFunction(Text, Priority)
 
      'Addchat VByellow, Priority & ") IsFunction Start: " & Text
      
      Dim TmpList, Tmp
      IsFunction = 0
      If Instr(Text, "(") < 2 Then Exit Function
      Text = LCase(Mid(Text, 2, Instr(Text, "(") - 2))
      Priority = Int(Priority)
      '//List the built-in functions here.
      'Remember to Put things like "abcbla" infront of "abc"
      If Priority = 1 Then
         TmpList = Array("seco", "secf", "round", "getgid", "count", "xitem", "item", _
         "if", "ifnot", "switch", "for", "rand", "mid", "instr", "chr", "no@", "getdl", "var", "math", _
         "do", "listitem", "listout", "inlist", "getdef")
         IsFunction = 0
         For Each Func in TmpList
            If Text = Func Then
               IsFunction = Len(Func) + 1
               Exit For
            End If
         Next
      End If
 
      If Priority = 2 Then
         TmpList = Array("die", "wait", "makecc", "pfunc", "setdl", "setvar", "withdl", "withvar", _
         "listclear", "listadd", "listdel", "gethttp", "setdef")
         For Each Func in TmpList
            Tmp = InStr(1, Text, "%" & Func, 1)
            If Text = Func Then
               IsFunction = Len(Func) + 1
               Exit For
            End If
         Next
      End If
      '//Check Registered functions:
      For Each Func in Me.FuncList
         If Text = Lcase(Func) Then
            If Me.FuncList.Item(Func)(2) = Priority Then
               IsFunction = Len(Func) + 1
               Exit For
            End If
         End If
      Next
      
      'Addchat VBYellow, "IsFunction End [" & IsFunction & "]"
      
   End Function
 
   '//A more forgiving/secure wraper for the Eval function
   Public Function SecureEval(Text)

      If Text = "" Then Exit Function
      '//Unparsed remnants should return null.
      If Left(Text, 1) = "%" Then Exit Function
      Tmp = Replace(Text, "mod", "", 1, -1, 1)
      If UCase(Tmp) = LCase(Tmp) Then
         On Error Resume Next
         SecureEval = Eval(Text)
         If Err.Number = 1032 Then
            SecureEval = Text
         ElseIf Err.Number Then
            Addchat VBred, "CC Error: Error occured when parsing Eval: " & Err.Number
         End If
         On Error Goto 0
      ElseIf InStr(Text, "=") Then
         Tmp = Split(Text, "=")
         Tmp(0) = """" & LCase(Trim(Tmp(0))) & """"
         Tmp(1) = """" & LCase(Trim(Tmp(1))) & """"
         SecureEval = Eval(Tmp(0) & "=" & Tmp(1))
      ElseIf InStr(Text, "<>") Then
         Tmp = Split(Text, "<>")
         Tmp(0) = """" & LCase(Trim(Tmp(0))) & """"
         Tmp(1) = """" & LCase(Trim(Tmp(1))) & """"
         SecureEval = Eval(Tmp(0) & "<>" & Tmp(1))
      '//Alias
      ElseIf InStr(Text, "!=") Then
         Tmp = Split(Text, "!=")
         Tmp(0) = """" & LCase(Trim(Tmp(0))) & """"
         Tmp(1) = """" & LCase(Trim(Tmp(1))) & """"
         SecureEval = Eval(Tmp(0) & "<>" & Tmp(1))
      Else
         SecureEval = Text
      End If
   End Function
 
   '//Written By Ronin ; Edited by Snap.
   Public Function FindCommands(What, Access, Flags)
 
      FindCommands = ""
      Dim Keys
      Keys = Me.CC.Keys
      If What <> "" Then Keys = Filter(Keys, What, True)
      
      For Each Key in Keys
         If Me.HasAccess(Key, Access, Flags) Then
            FindCommands = FindCommands & Key & ", "
         End If
      Next
 
      If Right(FindCommands, 2) = ", " Then FindCommands = Left(FindCommands, Len(FindCommands) - 2)
   End Function
 
   '//Returns True/False
   Public Function HasAccess(MyCommand, MyAccess, MyFlags)
 
      If Not Me.CC.Exists(MyCommand) Then Exit Function
      Dim ReqFlags, ReqAccess
      MyFlags = UCase(MyFlags)
      ReqFlags = UCase(Me.CC.Item(MyCommand).Flags)
      ReqAccess = Int(Me.CC.Item(MyCommand).Access)
      
      If MyAccess >= ReqAccess OR ReqAccess = 0 Then
         HasAccess = True
      Else
         HasAccess = False
         Exit Function
      End If
      For I = 1 to Len(ReqFlags)
         If InStr(MyFlags, Mid(ReqFlags, I, 1)) = 0 Then
            HasAccess = False
            Exit Function
         End If
      Next
   End Function
   
   '//Time related function
   '//Returns the time/date of Seconds seconds ago.
   Public Function SecondsToOrgin(Seconds)
   
      SecondsToOrgin = DateAdd("s", -Seconds, Now)
      If FormatDateTime(SecondsToOrgin, vbShortDate) = FormatDateTime(Date, vbShortDate) Then
         SecondsToOrgin = DateAdd("s", -Seconds, Time)
      End If
   End Function
   
   '//Turns seconds into something like: "6 Day(s) 23:01:52"
   Public Function SecondsToTime(Seconds)
   
      Dim Days, Hours, Minutes
      Days = Int(Seconds / 86400)
      Seconds = Seconds MOD 86400
      Hours = AddZero(Int(Seconds / 3600))
      Seconds = Seconds MOD 3600
      Minutes = AddZero(Int(Seconds / 60))
      Seconds = AddZero(Seconds MOD 60)
      
      If Days Then
         SecondsToTime = Days & " Day(s) " & Hours & ":" & Minutes & ":" & Seconds
      ElseIf Hours Then
         SecondsToTime = Hours & ":" & Minutes & ":" & Seconds
      Else
         SecondsToTime = Minutes & ":" & Seconds
      End If
   End Function
   
   Private Function AddZero(Number)
   
      If Len(Number) = 1 Then
         AddZero = "0" & Number
      Else
         AddZero = Number
      End If
   End Function
 
   '//Public Use Functions   
   Public Sub RegisterFunction(Name, CallBack, Args, Priority)
 
   '//psSC.Procedures(Name).NumArgs
   '//GetBotVersion
      If FuncList.Exists(Name) Then
         Addchat VBred, "CCX Error: Duplicate function registered!: " & Name
      Else
         FuncList.Add Name, Array(CallBack, Args, Priority)
      End If
   End Sub
 
   Public Function UnregisterFunction(Name)
 
      If FuncList.Exists(Name) Then
         FuncList.Remove(Name)
         UnregisterFunction = True
      Else
         UnregisterFunction = False
      End If
   End Function
   
   
   
   '==WRITE ME YOURSELF SNAP!!
       '**************************************
    ' Name: Roman Numerals
    ' Description:This converts a number to 
    '     roman numerals.
    ' By: Sock
    '
    ' Inputs:The number you want to format.
    '
    ' Returns:The roman numeral for that num
    '     er.
    '
    'This code is copyrighted and has    ' limited warranties.Please see http://w
    '     ww.Planet-Source-Code.com/vb/scripts/Sho
    '     wCode.asp?txtCodeId=7078&lngWId=4    'for details.    '**************************************
    
    'example usage:
    'response.write "2001: " & roman(2001)
    'or msgbox "2001: " & roman(2001)
    function roman(number)
    Dim v, w, x, y
    Dim str1
    Dim roman_unit
    Dim roman_tens
    Dim roman_hund
    Dim roman_thou
    roman_unit = Array("","I","II","III","IV","V","VI","VII","VIII","IX")
    roman_tens = Array("","X","XX","XXX","XL","L","LX","LXX","LXXX","XC")
    roman_hund = Array("","C","CC","CCC","CD","D","DC","DCC","DCCC","CM")
    roman_thou = Array("","M","MM","MMM","MMMM","MMMMM")
    v = 0
    w = 0
    x = 0
    y = 0
    v = ((number - (number mod 1000)) / 1000)
    number = (number mod 1000)
    w = ((number - (number mod 100)) / 100)
    number = (number mod 100)
    x = ((number - (number mod 10)) / 10)
    y = (number mod 10)
    roman = roman_thou(v) & roman_hund(w) & roman_tens(x) & roman_unit(y)
    End function
   
   Public Function Alpha(ByVal Number)
   
      If Number > 0 Then
         Number = Number - 1
         Alpha = Chr((Number MOD 26) + 65)
         If Int(Number / 26) MOD 2 = 1 Then
            Alpha = Lcase(Alpha)
         End If
      End If
   End Function
   
   
   
End Class
 [10:26:37 AM]  [10:26:37 AM] 'defs
'1.0
'&Definitions:Hdx
'&define:newdef <phrase>|<definition>:deldef
'&
'&Replacement for the internal Define/NewDef/DelDef commands.

Sub defs_Event_WhisperFromUser(Username, Flags, Message)
  If Left(Message, Len(BotVars.Trigger)) = BotVars.Trigger Then
    Dim myAccess, myFlags
    GetDBEntry Username, myAccess, myFlags
    call defs_ParseCommand(3, Username, myAccess, myFlags, Mid(Message, Len(BotVars.Trigger)+1))
  End If
End Sub

Sub defs_Event_UserTalk(Username, Flags, Message, Ping)
  If Left(Message, Len(BotVars.Trigger)) = BotVars.Trigger Then
    Dim myAccess, myFlags
    GetDBEntry Username, myAccess, myFlags
    call defs_ParseCommand(1, Username, myAccess, myFlags, Mid(Message, Len(BotVars.Trigger)+1))
  End If
End Sub

Sub defs_Event_PressedEnter(Text)
  If Left(Text, 1) = "/" Then
    Dim veto
    If Left(Text, 2) = "//" Then
        veto = defs_ParseCommand(1, vbNullstring, 1001, "A", Mid(Text, 3))
    Else
        veto = defs_ParseCommand(4, vbGreen, 1001, "A", Mid(Text, 2))
    End If
    If (veto = 1) Then VetoThisMessage
  End If
End Sub
'------------------------------------------------------------
Sub defs_define(Source, Username, myAccess, myFlags, Message)
  Dim strDef
  If(myAccess >= 60 Or InStr(1, myFlags, "A", vbTextCompare)) Then
    If(Len(Message) = 0) Then
      Call DSP(Source, "Error: Please format your query correctly. (.define term)", Username)
    Else
      strDef = GetConfigEntry("Def", Message, "definitions.ini")
      If(Len(strDef) > 0) Then
        Call DSP(Source, "Definition for " & Chr(&h22) & Message & Chr(&h22) & ": " & strDef, Username)
      Else
        Call DSP(Source, "Definition for " & Chr(&h22) & Message & Chr(&h22) & " not found.", Username)
      End If
    End If
  End If
End Sub

'------------------------------------------------------------
Sub defs_newdef(Source, Username, myAccess, myFlags, Message)
  Dim strWord, strDef, iPos
  If(myAccess >= 60 Or InStr(1, myFlags, "A", vbTextCompare)) Then  
    iPos = InStr(1, Message, "|", vbTextCompare)
    If(iPos < 2) Then
      Call DSP(Source, "Error: Please format your definitions correctly. (.newdef term|definition)", Username)
    Else
      strWord = Left(Message, iPos-1)
      strDef = Mid(Message, iPos+1)
      If(Len(strWord) = 0 Or Len(strDef) = 0) Then
        Call DSP(Source, "Error: Please format your definitions correctly. (.newdef term|definition)", Username)
      Else
        Call WriteConfigEntry("Def", strWord, strDef, "definitions.ini")
        Call DSP(Source, "Added a definition for " & Chr(&h22) & strWord & Chr(&h22) & ".", Username)
      End If
    End If
  End If
End Sub

'------------------------------------------------------------
Sub defs_deldef(Source, Username, myAccess, myFlags, Message)
  Dim strDef
  If(myAccess >= 60 Or InStr(1, myFlags, "A", vbTextCompare)) Then
    If(Len(Message) = 0) Then
      Call DSP(Source, "Error: Please format your query correctly. (.DelDef term)", Username)
    Else
      strDef = GetConfigEntry("Def", Message, "definitions.ini")
      If(Len(strDef) > 0) Then
        Call WriteConfigEntry("Def", Message, vbNullString, "definitions.ini")
        Call DSP(Source, "Definition for " & Chr(&h22) & Message & Chr(&h22) & " deleted.", Username)
      Else
        Call DSP(Source, "Definition for " & Chr(&h22) & Message & Chr(&h22) & " not found.", Username)
      End If
    End If
  End If
End Sub

'------------------------------------------------------------
Function defs_ParseCommand(Source, Username, myAccess, myFlags, Message)
  Dim strCommand
  strCommand = LCase(Split(Message & Space(1), Space(1))(0))
  Select Case strCommand
    case "newdef", "adddef": Call defs_NewDef(Source, Username, myAccess, myFlags, Mid(Message, Len(strCommand) + 2))
    case "define", "def":    Call defs_Define(Source, Username, myAccess, myFlags, Mid(Message, Len(strCommand) + 2))
    case "deldef", "remdef": Call defs_DelDef(Source, Username, myAccess, myFlags, Mid(Message, Len(strCommand) + 2))
    Case Else: Exit Function
  End Select
  defs_ParseCommand = 1
End Function
 [10:26:37 AM]  [10:26:37 AM] Warning: The file "timeban.plug" has been modified to function correctly with multiple-character triggers.
 [10:26:37 AM]  [10:26:37 AM] 'timeban
'1.373
'&Timeban Script:Swent
'&timeban <username> <time> [reason]:untimeban <username>:timebanned:ctbl
'&8970
'&From inside the bot, use "/" as your trigger:The <time> arguement is in minutes, and must be an integer:To use something other than minutes use .timeban <username> <x>/<time> [reason]: <x> can be d (days), h (hours), or s (seconds):Example - ".timeban Joe s/30" would timeban Joe for 30 seconds:Example - ".timeban Joe 5" would timeban Joe for 5 minutes

'// Last Updated 3:46 AM 6/3/2007 by Swent

'// ver 1.373
'//   *Fixed an error with untimebanning which created the potential for flood outs at bot login

'// ver 1.372
'//   *Timebanning illegal usernames that contain "|" will no longer cause errors (Thanks ProxyShare)

'// ver 1.371
'//   *Fixed a temporary error related to checks for channel operator status (Thanks Chobyhy)

'// ver 1.37
'//   *Added protection from external timeban commands for safelisted users
'//      -There is no protection from timeban commands originating from the bot console

'// ver 1.36
'//   *Fixed banning/unbanning problems for Diablo 2 users


Public tbPath      '// holds path to the timebanned users text file
Public tbUsers     '// holds data about users that are currently timebanned
Public tbDisplay   '// holds command output display type
Public tbBan(2)    '// holds ban message
Public tbUnban(2)  '// holds user who's being unbanned after an expired timeban
Public tbOffline   '// holds users that were offline when their timeban expired
Public tbConUptime '// holds bot's connection uptime in seconds
Public tbFSO       '// holds the FSO


'/*************************
'* PROGRAM SETTINGS       *
'*************************/

'// Access requirements
Const timeban_cmd_access    = 60
Const untimeban_cmd_access  = 60
Const timebanned_cmd_access = 60
Const ctbl_cmd_access       = 60

'// Command names
Const timeban_command    = "timeban"    '// Command to timeban a user
Const untimeban_command  = "untimeban"  '// Command to end a user's timeban
Const timebanned_command = "timebanned" '// Command to list users that are currently timebanned
Const ctbl_command       = "ctbl"       '// Command to clear list of timebanned users

'// Output Display Type
'//   1: Public | 2: Emoted | 3: Whispered
Const tb_display_type = 3

'/*************************
'* DO NOT EDIT BELOW HERE *
'*************************/


Sub timeban_Event_Load()

  Set tbFSO = CreateObject("Scripting.FileSystemObject")
  tbPath = BotPath & "timebanned_users.dat"

  '// Get list of timebanned users from the text file
  If Not tbFSO.FileExists(tbPath) Then
    Set tbFile = tbFSO.CreateTextFile(tbPath)
    ReDim tbUsers(0)
  Else
    Set tmpFile = tbFSO.GetFile(tbPath)
    If tmpFile.Size = 0 Then
      ReDim tbUsers(0)
    Else
      Set File = tbFSO.OpenTextFile(tbPath, 1)
      tbUsers = Split(File.ReadAll(), vbCrLf)
      File.Close
    End If
  End If

  TimerInterval "timeban", "tbTimer", 1
  TimerEnabled "timeban", "tbTimer", True
End Sub


Sub timeban_Event_ServerError(Message)

  If Message = "That user is not logged on." Then

    '// If timebanned user is offline, display timeban line
    If tbBan(0) Then
      dsp tbDisplay, Replace(tbBan(1), chr(167), "(offline) "), tbBan(2), vbCyan
      tbBan(0) = False

    '// If a user's timeban expires and they're offline, rejoin channel to lift the ban
    ElseIf tbUnban(0) Then
      If Not IsArray(tbOffline) Then ReDim tbOffline(0)
      tbOffline(UBound(tbOffline)) = tbUnban(1)
      ReDim Preserve tbOffline(UBound(tbOffline) + 1)
      If tbUnban(2) = BotVars.Username Then tbDisplay = 4
      dsp tbDisplay, "One or more offline users' timebans have expired. To lift such ban(s) the bot will rejoin the channel after a short delay...", tbUnban(2), vbCyan
      PadQueue: AddQ "/rejoin"
      tbUnban(0) = False
    End If

  '// If timebanner doesn't have ops, display timeban line
  ElseIf Message = "You are not a channel operator." Then
    If tbBan(0) Then
      dsp tbDisplay, Replace(tbBan(1), chr(167), vbNullString), tbBan(2), vbCyan
      tbBan(0) = False
    End If
  End If
End Sub


Sub timeban_Event_ServerInfo(Message)
  
  If Instr(LCase(Message), "was unbanned by " & LCase(BotVars.Username)) Then
    If tbUnban(0) Then tbUnban(0) = False

  '// Protect against other bots' Ban Evasion / AutoBan
  ElseIf Instr(LCase(Message), "was banned by") Then
    bannedUser = Split(LCase(Message))(0)

    If Instr(Message, "Timebanned") Then
      If tbBan(0) Then tbBan(0) = False: Exit Sub
    End If

    '// Are there any users that were untimebanned while offline?
    If Not IsArray(tbOffline) Then Exit Sub

    If Instr(Message, "Ban Evasion") Or Instr(Message, "AutoBan") Then 

      '// Check for users that were offline when their timeban expired
      For i = 0 to UBound(tbOffline)
        If bannedUser = tbOffline(i) Then
          tbOffline(i) = vbNullString
          PadQueue: PadQueue: PadQueue
          AddQ "/unban " & psD2 & bannedUser
          AddQ "/w " & psD2 & bannedUser & " You have been unbanned."
        End If
      Next
    End If
  End If
End Sub


Sub timeban_Event_UserTalk(Username, Flags, Message, Ping)

  GetDBEntry Username, myAccess, myFlags
  If Not (Left(Message, Len(BotVars.Trigger)) = BotVars.Trigger Or Left(Message, 1) = "/") Then Exit Sub '// Not a command

  addchat vbred, ";"

  '// AddChat response if command is coming from inside bot
  If Username = BotVars.Username Then tbDisplay = 4 Else tbDisplay = tb_display_type End If

  '// Get command and arguements
  If Len(Message) < 2 Then Exit Sub
  cmd = Split(Mid(LCase(Trim(Message)), 2))

  '// Call the appropriate command sub
  Select Case cmd(0)
    Case timeban_command, "tban": timeban_cmd cmd, Username, myAccess, Message
    Case untimeban_command, "utban": untimeban_cmd cmd, Username, myAccess
    Case timebanned_command, "tbanned": timebanned_cmd Username, myAccess
    Case ctbl_command: ctbl_cmd Username, myAccess
  End Select
End Sub


Sub timeban_Event_UserJoins(Username, Flags, Message, Ping, Product, Level, OriginalStatString, Banned)

  Call TimebanCheck(Username)
End Sub


Sub timeban_Event_UserInChannel(Username, Flags, Message, Ping, Product, StatUpdate)

  Call TimebanCheck(Username)
End Sub


Sub timeban_Event_LoggedOn(Username, Product)

  tbConUptime = 0
End Sub


Sub timeban_Event_PressedEnter(Text)

  If Len(Text) < 2 Or Left(Text, 1) <> "/" Then Exit Sub
  cmd = Split(Mid(LCase(Trim(Text)), 2), " ")

  Select Case cmd(0)
    Case timeban_command, untimeban_command, timebanned_command, ctbl_command, "tban", "utban", "tbanned"
      VetoThisMessage
      timeban_Event_UserTalk BotVars.Username, "", Text, 0
  End Select
End Sub


Sub timeban_tbTimer_Timer()

  '// Update connection uptime
  If IsOnline Then tbConUptime = tbConUptime + 1

  '// Is anyone timebanned and is the bot online?
  If Join(tbUsers, vbNullString) = vbNullString Or Not IsOnline Then Exit Sub

  For i = 0 to UBound(tbUsers)
    If tbUsers(i) <> vbNullString Then
      arrUser = Split(tbUsers(i), "|")
      strUser = Replace(arrUser(0),  chr(0), "|")

      If DateDiff("s", Now, arrUser(4)) <= 0 Then

        '// This user's timeban has ended
        tbUsers(i) = vbNullString
        tbUnban(0) = True: tbUnban(1) = strUser: tbUnban(2) = BotVars.Username
        AddQ "/unban " & psD2 & strUser

        '// Omit further messages if the bot has just logged on (to prevent flooding)
        If tbConUptime > 30 Then
	  If DateDiff("s", arrUser(3), Now) > 60 Then AddQ strUser & "'s timeban has expired."
          AddQ "/w " & psD2 & strUser & " Your timeban has expired. You have been unbanned."
        End If
      End If
    End If
  Next
End Sub


Sub timeban_Event_Close()

  If tbFSO.FileExists(tbPath) Then
    tbFSO.DeleteFile(tbPath)
  End If

  If Join(tbUsers) <> vbNullString Then
    Set File = tbFSO.OpenTextFile(tbPath, 2, True)
    For i = 0 to UBound(tbUsers)
      If tbUsers(i) <> vbNullString Then
        File.WriteLine tbUsers(i)
      End If
    Next
    File.Close
  End If
End Sub


Sub timeban_cmd(cmd, Username, Access, Message)

  If Access < timeban_cmd_access Then Exit Sub

  If UBound(cmd) < 2 Then
    If UBound(cmd) = 1 Then
      If cmd(1) = "on" Or cmd(1) = "off" Then Exit Sub
    End If
    tb_error 1, Username: Exit Sub
  End If

  '// Make sure the the user isn't already timebanned
  If IsArray(GetTimebanData(cmd(1))) Then
    tb_error 2, Username: Exit Sub
  End If

  '// Make sure the user isn't an op
  intBnetFlags = GetInternalDataByUsername(cmd(1), 1)
  If intBnetFlags > 0 And (intBnetFlags And 2) Then
    tb_error 3, Username: Exit Sub
  End If

  '// If this is an external cmd, make sure user isn't safelisted
  If Username <> BotVars.Username And IsSafelisted(cmd(1)) Then
    tb_error 4, Username: Exit Sub
  End If

  '// Store the current date variable
  curDate = Now()

  '// Get duration of timeban
  If Instr(cmd(2), "/") Then strArg = cmd(2) Else strArg = "n/" & cmd(2) End If
  arrDuration = Split(strArg, "/")
    
  '// Make sure the time arguement is an integer
  If IsNumeric(arrDuration(1)) Then
    If Int(arrDuration(1)) - arrDuration(1) <> 0 Then
      tb_error 5, Username: Exit Sub
    End If
  Else
    tb_error 5, Username: Exit Sub
  End If

  '// Make sure they've entered a valid time letter
  If UBound(Filter(Array("d","h","n","s"), arrDuration(0))) = -1 Then
    tb_error 6, Username: Exit Sub
  End If

  '// Get date/time at which user will unbanned
  utbDate = DateAdd(arrDuration(0), arrDuration(1), curDate)

  '// Create a string showing the number of days/hours/minutes/seconds user will be timebanned for
  Select Case arrDuration(0)
    Case "d": strTime = arrDuration(1) & " day"
    Case "h": strTime = arrDuration(1) & " hour" 
    Case "n": strTime = arrDuration(1) & " minute"
    Case "s": strTime = arrDuration(1) & " second"
  End Select
  If arrDuration(1) > 1 Then strTime = strTime & "s"

  '// Get the reason
  If UBound(cmd) > 2 Then
    arrMsg = Split(Message)
    For i = 3 to UBound(arrMsg)
      reason = reason & arrMsg(i) & " "
    Next
    dspReason = " [" & RTrim(reason) & "]"
    reason = Replace(dspReason, "|", chr(0))
  End If

  '// Add user with timebanner's name, reason, current date/time, and date/time of unban
  ReDim Preserve tbUsers(UBound(tbUsers) + 1)
  tbUsers(UBound(tbUsers)) = Join(Array(Replace(cmd(1), "|", chr(0)), Username, reason, curDate, utbDate), "|")

  '// Save the ban message in case this user is offline
  tbBan(0) = True: tbBan(1) = "Timebanned " & cmd(1) & " " & chr(167) & "for " & strTime & dspReason & ".": tbBan(2) = Username

  AddQ "/ban " & psD2 & cmd(1) & " Timebanned for " & strTime & dspReason
End Sub


Sub untimeban_cmd(cmd, Username, Access)

  If Access < untimeban_cmd_access Then Exit Sub

  tbanData = GetTimebanData(cmd(1))

  '// Make sure this user isn't already timebanned
  If IsArray(tbanData) Then
    tbUsers(tbanData(5)) = vbNullString
    tbUnban(0) = True: tbUnban(1) = cmd(1): tbUnban(2) = Username
    AddQ "/unban " & psD2 & cmd(1)
    dsp tbDisplay, cmd(1) & " is no longer timebanned.", Username, vbCyan
  Else
    dsp tbDisplay, "That user is not timebanned.", Username, vbCyan
  End If
End Sub


Sub timebanned_cmd(Username, Access)

  If Access < timebanned_cmd_access Then Exit Sub

  ReDim dispUsers(0)

  For i = 0 to UBound(tbUsers)
    If tbUsers(i) <> vbNullString Then
      arrUser = Split(tbUsers(i), "|")
      dispUsers(UBound(dispUsers)) = Replace(arrUser(0), chr(0), "|") & " (" & tbGetTimeLeft(arrUser(4)) & ")"
      ReDim Preserve dispUsers(UBound(dispUsers) + 1)
    End If
  Next

  If Join(dispUsers, vbNullString) = vbNullString Then
    dsp tbDisplay, "No users are timebanned.", Username, vbCyan
  Else
    ReDim Preserve dispUsers(UBound(dispUsers) - 1)
    dsp tbDisplay, "Timebanned users: " & Join(dispUsers, ", "), Username, vbCyan
  End If
End Sub


Sub ctbl_cmd(Username, Access)

  If Access < ctbl_cmd_access Then Exit Sub

  ReDim tbUsers(0)

  dsp tbDisplay, "Timebanned user list cleared.", Username, vbCyan
End Sub


Sub TimebanCheck(Username)

  tbanData = GetTimebanData(Username)
  If IsArray(tbanData) Then
    If Len(tbanData(2)) > 0 Then reason = Replace(tbanData(2), chr(0), "|")
    AddQ "/ban " & psD2 & Username & " Timebanned" & reason & ". " & tbGetTimeLeft(tbanData(4)), 1
  End If
End Sub


Function GetTimebanData(Username)

  For i = 0 to UBound(tbUsers)
    If tbUsers(i) <> vbNullString Then
      arrUser = Split(tbUsers(i), "|")
      If arrUser(0) = Replace(LCase(Username), "|", chr(0)) Then
        ReDim Preserve arrUser(5): arrUser(5) = i
        GetTimebanData = arrUser
        Exit Function
      End If
    End If
  Next
End Function


Function tbGetTimeLeft(UTBDate)

  daysLeft = DateDiff("d", Now, UTBDate)
  hoursLeft = DateDiff("h", Now, UTBDate)
  minutesLeft = DateDiff("n", Now, UTBDate)
  secondsLeft = DateDiff("s", Now, UTBDate)
  If daysLeft > 2 Then
    tbGetTimeLeft = "Days left: " & daysLeft
  ElseIf hoursLeft > 1 Then
    tbGetTimeLeft = "Hours left: " & hoursLeft
  ElseIf minutesLeft > 1 Then
    tbGetTimeLeft = "Minutes left: " & minutesLeft
  Else
    tbGetTimeLeft = "Seconds left: " & secondsLeft
  End If
End Function


Sub tb_error(errNum, Username)

  Select Case errNum
    Case 1: errString = "Proper format: " & BotVars.Trigger & "timeban <username> <time>"
    Case 2: errString = "That user is already timebanned."
    Case 3: errString = "You can't timeban a channel operator."
    Case 4: errString = "That user is safelisted."
    Case 5: errString = "The Time arguement must be an integer."
    Case 6: errString = "You used an invalid time letter. Valid letters: d, h, s"
  End Select

  dsp tbDisplay, "Timeban command error: " & errString, Username, vbRed
End Sub

 [10:26:37 AM]  [10:26:37 AM] Loaded 3 plugins (3 enabled). Type  [10:26:37 AM] /plugins [10:26:37 AM]  to view them. Type  [10:26:37 AM] /phelp [10:26:37 AM]  for help using them.
 [10:26:37 AM]  [10:26:37 AM] Type  [10:26:37 AM] /updates [10:26:37 AM]  in the bot to view updates and new plugins that are available for download.
 [10:26:48 AM] Shutting down...
 [10:28:01 AM] -> Welcome to StealthBot Beta v2.6999, by Stealth.
 [10:28:01 AM] -> If you enjoy StealthBot, consider supporting its development at http://support.stealthbot.net
 [10:28:01 AM]  [10:28:01 AM] Warning: One or more scripts found do not currently support the use of multiple-character triggers. Because of this, a backwards-compatibility mode has been enabled to allow the use of such scripts while using a multiple-character trigger.
 [10:28:01 AM]  [10:28:01 AM] Loaded 3 plugins (3 enabled). Type  [10:28:01 AM] /plugins [10:28:01 AM]  to view them. Type  [10:28:01 AM] /phelp [10:28:01 AM]  for help using them.
 [10:28:01 AM]  [10:28:01 AM] Type  [10:28:01 AM] /updates [10:28:01 AM]  in the bot to view updates and new plugins that are available for download.
 [10:28:23 AM] Shutting down...
 [10:37:49 AM] -> Welcome to StealthBot Beta v2.6999, by Stealth.
 [10:37:49 AM] -> If you enjoy StealthBot, consider supporting its development at http://support.stealthbot.net
 [10:37:49 AM]  [10:37:49 AM] Warning: One or more scripts found do not currently support the use of multiple-character triggers. Because of this, a backwards-compatibility mode has been enabled to allow the use of such scripts while using a multiple-character trigger.
 [10:37:49 AM]  [10:37:49 AM] Loaded 3 plugins (3 enabled). Type  [10:37:49 AM] /plugins [10:37:49 AM]  to view them. Type  [10:37:49 AM] /phelp [10:37:49 AM]  for help using them.
 [10:37:49 AM]  [10:37:49 AM] Type  [10:37:49 AM] /updates [10:37:49 AM]  in the bot to view updates and new plugins that are available for download.
 [10:38:00 AM] Shutting down...
 [05:12:36 PM] -> Welcome to StealthBot Beta v2.6999, by Stealth.
 [05:12:36 PM] -> If you enjoy StealthBot, consider supporting its development at http://support.stealthbot.net
 [05:12:37 PM]  [05:12:37 PM] Warning: One or more scripts found do not currently support the use of multiple-character triggers. Because of this, a backwards-compatibility mode has been enabled to allow the use of such scripts while using a multiple-character trigger.
 [05:12:37 PM]  [05:12:37 PM] Loaded 3 plugins (3 enabled). Type  [05:12:37 PM] /plugins [05:12:37 PM]  to view them. Type  [05:12:37 PM] /phelp [05:12:37 PM]  for help using them.
 [05:12:37 PM]  [05:12:37 PM] Type  [05:12:37 PM] /updates [05:12:37 PM]  in the bot to view updates and new plugins that are available for download.
 [05:12:57 PM] Connecting your bot...
 [05:12:57 PM] Authorizing your private-release bot, please wait.
 [05:12:57 PM] - - - - - YOU ARE NOT AUTHORIZED TO USE THIS PROGRAM - - - - -
 [05:12:57 PM] All connections closed.
 [05:15:20 PM] Shutting down...
 [05:16:31 PM] -> Welcome to StealthBot Beta v2.6999, by Stealth.
 [05:16:31 PM] -> If you enjoy StealthBot, consider supporting its development at http://support.stealthbot.net
 [05:16:31 PM]  [05:16:31 PM] Warning: One or more scripts found do not currently support the use of multiple-character triggers. Because of this, a backwards-compatibility mode has been enabled to allow the use of such scripts while using a multiple-character trigger.
 [05:16:31 PM]  [05:16:31 PM] Loaded 3 plugins (3 enabled). Type  [05:16:31 PM] /plugins [05:16:31 PM]  to view them. Type  [05:16:31 PM] /phelp [05:16:31 PM]  for help using them.
 [05:16:31 PM]  [05:16:31 PM] Type  [05:16:31 PM] /updates [05:16:31 PM]  in the bot to view updates and new plugins that are available for download.
 [05:16:33 PM] Shutting down...
 [05:24:20 PM] -> Welcome to StealthBot Beta v2.6999, by Stealth.
 [05:24:20 PM] -> If you enjoy StealthBot, consider supporting its development at http://support.stealthbot.net
 [05:24:21 PM]  [05:24:21 PM] Warning: One or more scripts found do not currently support the use of multiple-character triggers. Because of this, a backwards-compatibility mode has been enabled to allow the use of such scripts while using a multiple-character trigger.
 [05:24:21 PM]  [05:24:21 PM] Loaded 3 plugins (3 enabled). Type  [05:24:21 PM] /plugins [05:24:21 PM]  to view them. Type  [05:24:21 PM] /phelp [05:24:21 PM]  for help using them.
 [05:24:21 PM]  [05:24:21 PM] Type  [05:24:21 PM] /updates [05:24:21 PM]  in the bot to view updates and new plugins that are available for download.
 [05:24:22 PM] Connecting your bot...
 [05:24:22 PM] Authorizing your private-release bot, please wait.
 [05:24:22 PM] - - - - - YOU ARE NOT AUTHORIZED TO USE THIS PROGRAM - - - - -
 [05:24:22 PM] All connections closed.
 [05:24:23 PM] Connecting your bot...
 [05:24:23 PM] Authorizing your private-release bot, please wait.
 [05:24:23 PM] - - - - - YOU ARE NOT AUTHORIZED TO USE THIS PROGRAM - - - - -
 [05:24:23 PM] All connections closed.
 [05:24:24 PM] Connecting your bot...
 [05:24:24 PM] Authorizing your private-release bot, please wait.
 [05:24:24 PM] - - - - - YOU ARE NOT AUTHORIZED TO USE THIS PROGRAM - - - - -
 [05:24:24 PM] All connections closed.
 [05:24:24 PM] Connecting your bot...
 [05:24:24 PM] Authorizing your private-release bot, please wait.
 [05:24:24 PM] - - - - - YOU ARE NOT AUTHORIZED TO USE THIS PROGRAM - - - - -
 [05:24:24 PM] All connections closed.
 [05:24:24 PM] Connecting your bot...
 [05:24:24 PM] Authorizing your private-release bot, please wait.
 [05:24:24 PM] - - - - - YOU ARE NOT AUTHORIZED TO USE THIS PROGRAM - - - - -
 [05:24:24 PM] All connections closed.
 [05:24:24 PM] Connecting your bot...
 [05:24:24 PM] Authorizing your private-release bot, please wait.
 [05:24:24 PM] - - - - - YOU ARE NOT AUTHORIZED TO USE THIS PROGRAM - - - - -
 [05:24:24 PM] All connections closed.
 [05:24:24 PM] Connecting your bot...
 [05:24:24 PM] Authorizing your private-release bot, please wait.
 [05:24:24 PM] - - - - - YOU ARE NOT AUTHORIZED TO USE THIS PROGRAM - - - - -
 [05:24:24 PM] All connections closed.
 [05:24:24 PM] Connecting your bot...
 [05:24:24 PM] Authorizing your private-release bot, please wait.
 [05:24:24 PM] - - - - - YOU ARE NOT AUTHORIZED TO USE THIS PROGRAM - - - - -
 [05:24:24 PM] All connections closed.
 [05:24:26 PM] Shutting down...
