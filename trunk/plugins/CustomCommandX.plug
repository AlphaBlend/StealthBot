'ccx
'1.32
'&Custom Command Xystem:Snap (SnapWilliam@Gmail.com)


'//Written By Snap
'//   Special Thanks:
'//DragoonHybrid99
'//Ribose
'//Jack
'//DeadlyWorkz
'//Ronin


' 2.6R3 and 2.6994 Compatible

 
'//The relatively ordinary "Do Not Edit Below" Line
'// Seriously though guys, don't edit this script, it's a highly evolving script right now.
'//  If you want to make a change, why not ask me - I might wish to implement it!
'-------------------------------


'//Leave this outside Event_Load - so that it executes before the other plugin's event_load's run.
'//This way they can register functions.
Public ccx
Set ccx = New ccxClass


Public BENCHMARK
'//Benchmark the CC's to test improvments.
Public Const DoBench = False


Sub ccx_Event_Load()

   '//See Class Initialize.
   '// Disable Built-In Commands.
   If GetBotVersion = "StealthBot v2.6" Then
      WriteConfigEntry "Numeric", "cmdadd", "1000", "access.ini"
      WriteConfigEntry "Numeric", "cmddel", "1000", "access.ini"
      WriteConfigEntry "Numeric", "cmdlist", "1000", "access.ini"
   End If
   
   If ccx.FSO.FileExists(BotPath() & "commands.dat") Then
      Convert BotPath() & "commands.dat", BotPath() & "BackupCmds.dat"
   End If
End Sub

Sub Convert(FileName, FileTo)
   '//Create the ADODB Stream
   Dim Binary, Data
   Set Binary = CreateObject("ADODB.Stream")
   Binary.Type = 2
   Binary.CharSet = "iso-8859-1"
   
   '//Open the file
   Binary.Open
   Binary.LoadFromFile FileName
   Data = Binary.ReadText
   Binary.Close
   
   If Len(Data) < 20 Then Exit Sub
   
   Addchat VBwhite, "CCX: Converting commands..."
   
   Dim Tmp, Access, Command, Response, Pointer, IntS, IntA
   '//Commands Added/Skiped
   IntA = 0 : IntS = 0
   '//Pointer holds the position where were looping.
   Pointer = 1
   '//Now to parse those commands.
   Do
      '//Access is first.
      '//Get the access in Binary
      Tmp = Mid(Data, Pointer, 2)
      '//Convert the Binary value
      Access = Eval("&H" & Hex(Asc(Right(Tmp, 1))) & Hex(Asc(Left(Tmp, 1))))
      '//Move along, move along
      Pointer = Pointer + 2
      
      '//This one is easy!
      Command = Trim(Mid(Data, Pointer, 20))
      Pointer = Pointer + 20
      '//Trim from the right, we want to save the spaces infront :).
      Response = RTrim(Mid(Data, Pointer, 500))
      '//Ya, I'm confused about it being one short of 500 too.
      Pointer = Pointer + 499
      '//Verify, and append the list.
      If Right(Command, 1) <> Chr(0) AND Len(Command) > 0 Then
         'SP = SP  & VBNewLine & Command & "*" & Access & "***" & Response
         If Not ccx.CC.Exists(Command) Then
            ccx.SaveCommand Command, Access, "", "", Response
            IntA = IntA + 1
         Else
            IntS = IntS + 1
         End If
      End If
   Loop Until Pointer > Len(Data)
   Addchat VByellow, "CCX: " & IntA & " commands have been successfully added. " & IntS & " command duplicates were skiped."
   '//Move the file
   Addchat VBwhite, "CCX: Backing up old commands file..."
   If ccx.FSO.FileExists(FileName & ".old") Then ccx.FSO.DeleteFile(FileName & ".old")
   ccx.FSO.MoveFile FileName, FileName & ".old"
   '//Create a blank file for 2.6 issues
   If GetBotVersion = "StealthBot v2.6" Then ccx.FSO.CreateTextFile(FileName)
   'ccx.FSO.CreateTextFile(FileName)
   Addchat VBwhite, "CCX: Commands have been converted to CCX"
End Sub



Sub ccx_Event_UserTalk(Username, Flags, Message, Ping)
   ccx_ProcessInput Username, Message, "Talk", Flags, Ping
End Sub

Sub ccx_Event_WhisperFromUser(Username, Flags, Message)
   ccx_ProcessInput Username, Message, "Whisper", Flags, 0
End Sub
 
Sub ccx_Event_PressedEnter(Text)
 
   If Left(Text, 4) = "/cc " Then
      VetoThisMessage
      AddQ ccx.ParseFunctions(Mid(Text, 5))
   End If

   If Left(Text, 2) = "//" Then
      ccx_ProcessInput Botvars.username, Mid(Text, 2), "UEnter", "", 0
      Exit Sub
   End If
   If Left(Text, 1) = "/" Then ccx_ProcessInput Botvars.username, Text, "Enter", "", 0
End Sub
 
 
'For ProcessInput
Sub ccx_R(Username, Message, Method)
 
   Select Case Method
      Case "Enter"
         AddChat vbCyan, Message
         'VetoThisMessage
         '//Double // commands.
      Case "UEnter"
         Dsp 1, Message, 0, 0
         'VetoThisMessage
      Case "Talk"
         Dsp 1, Message, 0, 0
      Case "Whisper"
         Dsp 3, Message, Username, 0
   End Select
 If DoBench = True Then Addchat VBwhite, GetGTC - BENCHMARK
End Sub

Public Function ccx_CommandAccess(Command)

   Dim Access, Tmp
   '//Built-In commands.
   Select Case Command
      Case "cclist", "listcc", "cmdlist"
         Access = 20
      Case "findcc", "findcmd"
         Access = 20
      Case "addcc", "addcmd", "cmdadd"
         Access = 100
      Case "delcc", "delcmd", "cmddel"
         Access = 100
      Case "renamecc", "renamecmd"
         Access = 90
      Case "showcc", "showcmd"
         Access = 80
      Case "testcc", "testcmd"
         Access = 100
      Case "reloadcc", "reloadcmd"
         Access = 100
      Case "setcc", "setcmd"
         Access = 100
      Case "editcc", "editcmd"
         Access = 100
      Case "clipcc", "clipcmd"
         Access = 100
      Case Default = 0
   End Select
   Tmp = GetConfigEntry("numeric", Command, "access.ini")
   If IsNumeric(Tmp) Then Access = Tmp
   
   ccx_CommandAccess = Access
End Function

 
Sub ccx_ProcessInput(Username, Message, Source, Flags, Ping)

   If Message = Botvars.trigger OR Message = "/" Then Exit Sub
   
   If DoBench = True Then BENCHMARK = GetGTC
   
   Dim Cmd
   If Left(Message, Len(Botvars.trigger)) = BotVars.Trigger Then
      Cmd = LCase(Split(Mid(Message, Len(Botvars.trigger) + 1))(0))
   ElseIf Left(Message, 1) = "/" Then
      Cmd = LCase(Split(Mid(Message, 2))(0))
   Else
      Exit Sub
   End If
   
   Dim RStr, RAry, Tmp, Tmp2, InBot, I
   
   RStr = Trim(Split(Message & " ", " ", 2)(1))
 
   GetDBEntry Username, UAccess, UFlags
   If Source = "Enter" OR Source = "UEnter" Then
      UAccess = 1000
      InBot = True
   End If
   
   If NOT (ccx_CommandAccess(Cmd) > UAccess) Then
      '//Built-In commands.
      Select Case Cmd
         Case "cclist", "listcc", "cmdlist"
            If InBot Then VetoThisMessage
            ccx_R Username, "Commands that you can use: " & ccx.FindCommands("", UAccess, UFlags), Source
         Case "findcmd", "findcc"
            If InBot Then VetoThisMessage
            Tmp = ccx.FindCommands(RStr, UAccess, UFlags)
            If Tmp <> "" Then
               ccx_R Username, "Matching commands (that you can use): " & Tmp, Source
            Else
               ccx_R Username, "No commands found. Example: " & Botvars.Trigger & "findcc note", Source
            End If
               
         Case "addcc", "addcmd", "cmdadd"
            If InBot Then VetoThisMessage
            RAry = Split(RStr, " ", 3)
    
            If UBound(RAry) <> 2 Then
               'Addchat VBwhite, "Command format: !addcc (name) (access)[/flags] (response)"
               ccx_R Username, "Example: !addcc givetea 20 /me gives %1 tea. Compliments of %user", Source
               Exit Sub
            End If
            Dim T_Flags, T_Access, T_Name
            If Isnumeric(RAry(1)) Then
               T_Access = RAry(1)
            Else
               If InStr(RAry(1), "/") Then
                  Tmp = Split(RAry(1), "/")
                  T_Access = Tmp(0)
                  If Not IsNumeric(Tmp(0)) AND Tmp(0) <> "" Then
                     ccx_R Username, "Bad you, no CC for you", Source
                     '//Invalid Format
                     Exit Sub
                  End If
                  T_Flags = Tmp(1)
               Else
                  ccx_R Username, "You must supply an access amount", Source
                  Exit Sub
               End If
            End If
            '//Rename command if existing.
            If ccx.CC.Exists(RAry(0)) Then
               For I = 1 to 40
                  If Not ccx.CC.Exists(RAry(0) & I) Then
                     T_Name = RAry(0) & I
                     ccx_R Username, "Command name was already taken - name changed to: " & T_Name & " You can use !renamecc to change it", Source
                     Exit For
                  End If
               Next
            Else
               T_Name = RAry(0)
            End If
    
            ccx.SaveCommand T_Name, T_Access, T_Flags, "", RAry(2)
            If T_Access = "" Then T_Access = "no"
            If T_Flags = "" Then T_Flags = "no"
            ccx_R Username, "Command """ & T_Name & """ [" & T_Access & " access/" & T_Flags & " flags] added.", Source
         Case "delcc", "delcmd", "cmddel"
            If InBot Then VetoThisMessage
            If ccx.CC.Exists(LCase(Rstr)) Then
               ccx.DeleteCommand Rstr
               ccx_R Username, "Command """ & Rstr & """ deleted.", Source
            Else
               ccx_R Username, "Command """ & Rstr & """ wasn't found.", Source
            End If
         Case "renamecc", "renamecmd"
            If InBot Then VetoThisMessage
            RAry = Split(RStr, " ")
            If UBound(RAry) <> 1 Then
               ccx_R Username, "Format: " & Botvars.trigger & "renamecc (command) (newname)", Source
               Exit Sub
            End If
            If Not ccx.CC.Exists(LCase(RAry(0))) Then
               ccx_R Username, "Command not found: " & RAry(0), Source
               Exit Sub
            End If
            If ccx.CC.Exists(LCase(RAry(1))) Then
               ccx_R Username, "Command already named: " & RAry(1), Source
               Exit Sub
            End If
    
            ccx.SaveCommand LCase(RAry(1)), ccx.CC.Item(RAry(0)).access, ccx.CC.Item(RAry(0)).flags, ccx.CC.Item(RAry(0)).trigger, ccx.CC.Item(RAry(0)).response
            ccx.DeleteCommand RAry(0)
            ccx_R Username, "Command renamed: " & RAry(0) & " -> " & RAry(1), Source
         Case "showcc", "showcmd"
            If InBot Then VetoThisMessage
            If RStr = "" Then
               ccx_R Username, "Please enter a command name.", Source
               Exit Sub
            End If
            If Not ccx.CC.Exists(LCase(RStr)) Then
               ccx_R Username, "Command not found: " & RStr, Source
            Else
               With ccx.CC.Item(LCase(RStr))
                  ccx_R Username, "Command [" & LCase(RStr) & "][" & .Access & "/" & .Flags & "] " & .Response, Source
               End With
            End If
         Case "testcc", "testcmd"
            If InBot Then VetoThisMessage
            ccx_R Username, ccx.ParseFunctions(RStr), Source
         Case "reloadcc", "reloadcmd"
            If InBot Then VetoThisMessage
            ccx.LoadCommands
            ccx_R Username, "Commands reloaded from text file.", Source
            
         Case "setcc", "setcmd"
            If InBot Then VetoThisMessage
            If RStr = "" Then
               ccx_R Username, "Example: " & Botvars.trigger & "setcc MyCmd 50/M ", Source
               Exit Sub
            End If
            RAry = Split(RStr, " ", 2)
            Addchat Vbyellow, RAry(1)
            If ccx.CC.Exists(RAry(0)) Then
               If IsNumeric(RAry(1)) Then
                  T_Access = RAry(1)
               Else
                  If InStr(RAry(1), "/") Then
                     Tmp = Split(RAry(1), "/")
                     T_Access = Tmp(0)
                     If Not IsNumeric(Tmp(0)) AND Tmp(0) <> "" Then
                        ccx_R Username, "Bad you, no CC for you", Source
                        '//Invalid Format
                        Exit Sub
                     End If
                     T_Flags = Tmp(1)
                  Else
                     ccx_R Username, "You must supply an access amount", Source
                     Exit Sub
                  End If
               End If
               ccx.CC.Item(RAry(0)).Access = T_Access
               ccx.CC.Item(RAry(0)).Flags = T_Flags
               ccx.SaveChanges RAry(0)
               If T_Access = "" Then T_Access = "no"
               If T_Flags = "" Then T_Flags = "no"
               ccx_R Username, "Command """ & RAry(0) & """ set: [" & T_Access & " access/" & T_Flags & " flags]", Source
            End If
            
         Case "editcc", "editcmd"
            If InBot Then VetoThisMessage
            If RStr = "" Then
               ccx_R Username, "Example: " & Botvars.trigger & "editcc MyCmd New Response", Source
               Exit Sub
            End If
            RAry = Split(RStr, " ", 2)
            Addchat Vbyellow, RAry(1)
            If ccx.CC.Exists(RAry(0)) Then
               ccx.CC.Item(RAry(0)).Response = RAry(1)
               ccx.SaveChanges RAry(0)
               ccx_R Username, "Command: " & RAry(0) & " updated", Source
            End If
            
         Case "clipcc", "clipcmd"
            If InBot Then VetoThisMessage
            If RStr = "" Then
               ccx_R Username, "Please enter a command name.", Source
               Exit Sub
            End If
            If Not ccx.CC.Exists(LCase(RStr)) Then
               ccx_R Username, "Command not found: " & RStr, Source
            Else
               With ccx.CC.Item(LCase(RStr))
                  '//Thanks DeadlyWorkz
                  Dim objHTML
                  Set objHTML = CreateObject("htmlfile")
                  objHTML.parentWindow.clipboardData.setData "text", Botvars.trigger & "addcc " & LCase(RStr) & " " & .Access & "/" & .Flags & " " & .Response '// Set clipboard text
                  ccx_R Username, "Command [" & LCase(RStr) & "] Set to (Bot-Owners) Clipboard", Source
               End With
            End If
      End Select
   End If
 
   '==Protect against inf loops w/ %runcc (Public var within the loop check if it = 30 or something)
 
   If ccx.CC.Exists(Cmd) Then
      If InStr(Source, "Enter") Then VetoThisMessage
      
      Dim strRes
      With ccx.CC.Item(Cmd)
         If ccx.HasAccess(Cmd, UAccess, UFlags) = False Then Exit Sub
      
         strRes = .Response
      End With
      
      With ccx
         '//Escape special char's so you can't use %'s within %rest.
         RStr = .AddEscape(RStr)
         Username = .AddEscape(Username)
         
         'Addchat VByellow, strRes
         '//Basic replacments
         strRes = Replace(strRes, "%user", Username)
         strRes = Replace(strRes, "%trigger", Botvars.Trigger)
         strRes = Replace(strRes, "%0", Username)
         strRes = Replace(strRes, "%chancount", GetInternalUserCount())   
         strRes = Replace(strRes, "%chan", .AddEscape(MyChannel))
         strRes = Replace(strRes, "%access", UAccess)
         strRes = Replace(strRes, "%flags", UFlags)
         strRes = Replace(strRes, "%gtc", GetGTC())
         strRes = Replace(strRes, "%time", Time)
         strRes = Replace(strRes, "%date", Date)
         strRes = Replace(strRes, "%args", UBound(Split(RStr)) + 1)
         
    
         '//Clan Bnetflags Ping Product Safelisted Statstring Timeinchan Timesincetalk User/0 chancount chan access flags gtc time date
         If InStr(strRes, "%") Then strRes = ccx_ParseGID(strRes, Username)
         
         If Instr(strRes, "%ruser") Then
            For I = 16 To 1 Step - 1
               Tmp = .AddEscape(GetNameByPosition(Int(Rnd * GetInternalUserCount()) + 1))
               If Tmp2 = Tmp AND GetInternalUserCount() > 1 Then
                  '//Try again.
                  I = I + 1
               Else
                  Tmp2 = Tmp
                  strRes = Replace(strRes, "%ruser" & I, Tmp)
               End If
            Next
            strRes = Replace(strRes, "%ruser", Tmp)
         End If
         
         '//Parse the args - like %1, %2 %all etc.
         If InStr(strRes, "%") Then strRes = .ParseArgs(strRes, RStr)
         '//Parse all the functions.
         If InStr(strRes, "%") Then strRes = .ParseFunctions(strRes)
         If Source = "Enter" Then VetoThisMessage
         '// Bring back special chars to the response were sending.
         StrRes = .RemoveEscape(strRes)
         If InStr(StrRes, "& ") Then
            For Each Item In Split(strRes, "& ")
               '//This should be processed for /
               ccx_R Username, Item, Source
            Next
         Else
            ccx_R Username, StrRes, Source
         End If
      End With
   End If
End Sub


Public Function ccx_ParseGID(Text, Username)
 
   Text = Replace(Text, "%clan", GetInternalDataByUsername(Username, 0))
   Text = Replace(Text, "%bnetflags", GetInternalDataByUsername(Username, 1))
   Text = Replace(Text, "%ping", GetInternalDataByUsername(Username, 2))
   Text = Replace(Text, "%product", GetInternalDataByUsername(Username, 3))
   Text = Replace(Text, "%safelisted", GetInternalDataByUsername(Username, 4))
   Text = Replace(Text, "%statstring", GetInternalDataByUsername(Username, 5))
   Text = Replace(Text, "%timeinchan", GetInternalDataByUsername(Username, 6))
   Text = Replace(Text, "%timesincetalk", GetInternalDataByUsername(Username, 7))
   ccx_ParseGID = Text
End Function


'//Written By Zergmaster
Function CheckAccessFlags(Username, ReqA, ReqF)
    Dim UsrA, UsrF, i, ThisF
    CheckAccessFlags = False
    If LCase(Username) = "(console)" Or LCase(Username) = LCase(BotVars.Username) Or LCase(Username) = LCase(myUsername) Then
        CheckAccessFlags = True
        Exit Function
    End If
    On Error Resume Next
    If LCase(Username) = LCase(BotVars.BotOwner) Then
        CheckAccessFlags = True
        Exit Function
    End If
    Err.Clear()
    GetDBEntry Username, UsrA, UsrF
        If IsNumeric(ReqA) Then
               If ReqA > UsrA Then Exit Function
        End If
    If Len(ReqF) = 0 Then
        CheckAccessFlags = True
        Exit Function
    End If
    For i = 1 To Len(ReqF)
        ThisF = Mid(ReqF, i, 1)
        If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", UCase(ThisF)) Then
            If Not InStr(UCase(UsrF), UCase(ThisF)) Then Exit Function
        End If
    Next
    CheckAccessFlags = True
End Function


Class ccxCC
 
   Public Access, Flags, Response, Trigger
End Class


Class ccxClass
 
   Public CC
   Public FuncList
   Public FSO
   Public DL_Path
   Public CC_Path
   Private PendCC
   
   '//Return solution
   Public ReturnSol
   
   '//Anti Loop I. - Used for preventing an infinite loop.
   Private AntIloop
 
   Private Sub Class_Initialize()
 
      Set Me.FuncList = CreateObject("Scripting.Dictionary")
      Set Me.CC = CreateObject("Scripting.Dictionary")
      Me.CC.CompareMode = 1
      Me.FuncList.CompareMode = 1
      
      Set Me.FSO = CreateObject("Scripting.FileSystemObject")
      Me.DL_Path = ".\scripts\plugins\ccx_DL.txt"
      Me.CC_Path = ".\scripts\plugins\ccx_CC.txt"
      Me.LoadCommands
   End Sub
 
 
   Sub LoadCommands()
 
      Dim File, arrCmd
      Set File = Me.FSO.OpenTextFile(Me.CC_Path, 1, True)
      '//Clear first.
      Me.CC.RemoveAll
      Do While Not File.AtEndOfStream
         arrCmd = Split(File.ReadLine, "*", 2)
         If UBound(arrCmd) = 1 Then
            Dim StrName, ArrData
            StrName = LCase(arrCmd(0))
            ArrData = Split(arrCmd(1), "*", 4)
            Set Me.CC.Item(StrName) = New ccxCC
            Me.CC.Item(StrName).Access = ArrData(0)
            Me.CC.Item(StrName).Flags = ArrData(1)
            Me.CC.Item(StrName).Trigger = ArrData(2)
            Me.CC.Item(StrName).Response = ArrData(3)
         End If
      Loop
   End Sub

   Public Sub SaveCommand(Name, Access, Flags, Trigger, Response)
 
      Dim File, strCmd
      Set file = Me.FSO.OpenTextFile(Me.CC_Path, 8, True)
      File.Write VBNewLine & Name & "*" & Access & "*" & Flags & "*" & Trigger & "*" & Response
      'Me.CC.Add LCase(Name), Array(Access, Flags, Trigger, Command)
      Set Me.CC.Item(Name) = New ccxCC
      Me.CC.Item(Name).Access = Access
      Me.CC.Item(Name).Flags = Flags
      Me.CC.Item(Name).Trigger = Trigger
      Me.CC.Item(Name).Response = Response
   End Sub
   
   Public Sub DeleteCommand(Name)

      Name = LCase(Name)
      Dim File, Tmp
      '//Read File
      Set File = Me.FSO.OpenTextFile(Me.CC_Path, 1, True)
      If File.AtEndOfStream Then Exit Sub
      Tmp = File.Readall
      '//Write modified file
      Set File = Me.FSO.OpenTextFile(Me.CC_Path, 2, True)
      Tmp = Split(Tmp, vbNewLine)
      For Each Line In Tmp
         If (LCase(Split(Line & "*", "*")(0)) <> Name) AND Line <> "" Then
            File.Write VBNewLine & Line
         End If
      Next
      '//Remove from dictionary.
      Me.CC.Remove Name
   End Sub
 
 
   Public Sub SaveChanges(Name)
   
      '//Mostly just copy the DeleteCommand Sub
      Name = LCase(Name)
      Dim File, Tmp
      '//Read File
      Set File = Me.FSO.OpenTextFile(Me.CC_Path, 1, True)
      If File.AtEndOfStream Then Exit Sub
      Tmp = File.Readall
      '//Write modified file
      Set File = Me.FSO.OpenTextFile(Me.CC_Path, 2, True)
      Tmp = Split(Tmp, vbNewLine)
      For Each Line In Tmp
         If Line <> "" Then
            If (LCase(Split(Line & "*", "*")(0)) <> Name) Then
               File.Write VBNewLine & Line
            Else
               With Me.CC.Item(Name)
                  File.Write VBNewLine & Name & "*" & .Access & "*" & .Flags & "*" & .Trigger & "*" & .Response
               End With
            End If
         End If
      Next
   End Sub
   
 
   '//REPLACE FUNCTIONS
   '//Replaces Arguements
   '++Bench = 0ms
   Public Function ParseArgs(Command, Input) 'as string
 
      '//%1 %2 infinite.
      Dim strRes, I, Rest, RestB
      TextAry = Split(Input)
      strRes = Command
      For I = UBound(TextAry) to 0 Step - 1
         If InStr(strRes, "%" & I + 1) Then
            RestB = True
            Rest = Mid(Rest, 2)
            strRes = Replace(strRes, "%" & I + 1, TextAry(I))
         ElseIf Not RestB Then
            Rest = " " & TextAry(I) & Rest
         End If
      Next
      For I = UBound(TextAry) + 1 to 1 Step - 1
         strRes = Replace(strRes, "%all" & I, Split(Input, " ", I)(I - 1))
      Next
      strRes = Replace(strRes, "%all", Input)
      strRes = Replace(strRes, "%rest", Trim(Rest))
      ParseArgs = strRes
 
      '== Now loop through and remove any leftover %3's that may have been left.
      '== Consider replacing with %die, or stoping here.
   End Function
   
   Public Function AddEscape(Text) 'as string
   
      Text = Replace(Text, "%", Chr(240) & Chr(239))
      Text = Replace(Text, ",", Chr(240) & Chr(238))
      Text = Replace(Text, "(", Chr(240) & Chr(242))
      Text = Replace(Text, ")", Chr(240) & Chr(243))
      AddEscape = Text
   End Function
   
   Public Function RemoveEscape(Text) 'as string
   
      Text = Replace(Text, Chr(240) & Chr(239), "%")
      Text = Replace(Text, Chr(240) & Chr(238), ",")
      Text = Replace(Text, Chr(240) & Chr(242), "(")
      Text = Replace(Text, Chr(240) & Chr(243), ")")
      RemoveEscape = Text
   End Function
   
   Public Sub ResetAntIloop()
   
      AntIloop = 0
   End Sub
 
   '//Solves/replaces all functions. (aka Step 2-4)
   Public Function ParseFunctions(Text) 'as string
 
      '//Addchat VBwhite, "ParseFunctions Start"
      Dim NLoc, RLoc, ALoc
      Dim Priority
      RLoc = Len(Text)
      '//Goes through the command finding functions
      Priority = 1
      Do
         '//This will prevent CallCC loops, and other infinite loops. - AntiLoop is reset via Sub ResetAntILoop
         If AntIloop > 2000 Then
            Exit Function
         Else
            AntIloop = AntIloop + 1
         End If
         
         NLoc = InstrRev(Mid(Text, 1, RLoc), "%")
         If NLoc = 0 Then
            '//If Priority = 2 Then Exit Do
            If Priority = 1 Then
               '//Die
               If InStr(Text, "%die(") Then
                  NLoc = InStr(Text, "%die(")
               Else
                  NLoc = InstrRev(Text, "%")
                  If NLoc = 0 Then Exit Do
               End If
               '//Prevents things like %runcc from executing if %die is still around.
               Priority = 2
            Else
               Exit Do
            End If
         End If
         
         'If NLoc = 0 AND Instr(Text, "%") = 0 Then Exit Do
         
         Deep = me.IsFunction(Mid(Text, Nloc), Priority)
         ALoc = InStr(Mid(Text, NLoc + Deep), ")")
         REM If ALoc > InStr(Mid(Text, NLoc + Deep + 1), "(") Then
            REM Addchat VBred, Mid(Text, NLoc + Deep)
            REM Addchat VBwhite, "ello" & ALoc
            REM Addchat VByellow, "ello" & Instr(ALoc, Mid(Text, NLoc + Deep + 1), ")")
         REM End If
         '//Check %die
         If Priority = 2 AND Lcase(Mid(Text, Nloc, 4)) = "%die" Then
            ParseFunctions = Me.SolveFunction(Mid(Text, NLoc, Deep), Mid(Text, NLoc + Deep + 1, ALoc - 2))
            Exit Function
         End If
         
         If Deep AND ALoc <> 0 Then
            Dim Part1, Part2, Part3
            'the bird %jumped(over) the cat
            '//Create new text
            'the bird
            Part1 = Mid(Text, 1, NLoc - 1)
            '%jumped(over) -> Over Jumped!
            Part2 = Me.SolveFunction(Mid(Text, NLoc, Deep), Mid(Text, NLoc + Deep + 1, ALoc - 2))
            ' the cat
            Part3 = Mid(Text, NLoc + Deep + Aloc)
            Text = Part1 & Part2 & Part3
         Else
            RLoc = NLoc - 1
         End If
      Loop
      
      ParseFunctions = Text
      'Addchat VByellow, "End ParseFunctions - " & ParseFunctions
   End Function

   Public Function SolveFunction(Name, Args) 'as string
 
      'Addchat VByellow, "Solve Function start: " & Name
      
      Dim RStr
      Dim Tmp, Tmp2, I
      
      RStr = Args
      Args = Split(Args, ",")
      SolveFunction = ""
      '//Ignore the %
      Name = LCase(Mid(Name, 2))
 
      '//Built-In functions.
      Select Case Name
         Case "round" If UBound(Args) = 1 Then SolveFunction = Round(Args(0), Args(1))
         '//So powerful, so small...
         Case "if"
            If Me.SecureEval(Args(0)) <> False Then
               SolveFunction = Args(1)
            Else
               If UBound(Args) = 2 Then
                  SolveFunction = Args(2)
               Else
                  SolveFunction = ""
               End If
            End If
         Case "ifnot"
            If Me.SecureEval(Args(0)) <> True Then
               SolveFunction = Args(1)
            Else
               If UBound(Args) = 2 Then
                  SolveFunction = Args(2)
               Else
                  SolveFunction = ""
               End If
            End If
         '//Switch can come in handy!
         Case "switch"
            If UBound(Args) > 1 Then
               Tmp = Lcase(Me.SecureEval(Args(0)))
               For I = 1 to UBound(Args) Step 2
                  If Lcase(Me.SecureEval(Args(I))) = Tmp OR Lcase(Me.SecureEval(Args(I))) = "else" Then
                     SolveFunction = Args(I+1)
                     Exit Function
                  End If
               Next
            End If
         '//A loop? No wai!
         Case "for"
            If UBound(Args) > 1 Then
               If Isnumeric(Args(0)) AND Isnumeric(Args(1)) Then
                  Tmp2 = "%i"
                  If UBound(Args) = 3 Then Tmp2 = Args(3)
                  Tmp = 0
                  For I = Int(Args(0)) To Int(Args(1))
                     SolveFunction = SolveFunction & Replace(Args(2), Tmp2, I)
                     Tmp = Tmp + 1
                     If Tmp > 50 Then
                        SolveFunction = ""
                        Addchat VBred, "CC Error: %for loop cut off due to Loop MAX"
                     End If
                  Next
               End If
            End If
         '//Gota have this.
         Case "rand"
            If UBound(Args) = 1 Then
               Randomize
               SolveFunction = Int(Rnd * ((Args(1) + 1) - Args(0)) + Args(0))
            End If
         '//I'd rather make a mimic of PHP's StrSt function.
         Case "mid"
            If UBound(Args) = 2 Then
               SolveFunction = Mid(Args(0), Args(1), Args(2))
            ElseIf UBound(Args) = 1 Then
               SolveFunction = Mid(Args(0), Args(1))
            End If
         Case "item"
            If UBound(Args) = 1 Then
               Tmp = Split(Args(0))
               If UBound(Tmp) >= Int(Args(1)) - 1 Then SolveFunction = Tmp(Int(Args(1)) - 1)
            ElseIf UBound(Args) = 2 Then
               Tmp = Split(Args(0), Args(2))
               If UBound(Tmp) >= Int(Args(1)) - 1 Then SolveFunction = Tmp(Int(Args(1)) - 1)
            End If
         
         '//Returns everything except the item selected.
         Case "xitem"
            If UBound(Args) = 1 Then
               Tmp = Split(Args(0)) '//Space default
               If UBound(Tmp) >= Int(Args(1)) - 1 Then
                  Tmp(Int(Args(1)) - 1) = Chr(186) & "BURN"
                  Tmp = Filter(Tmp, Chr(186) & "BURN", False)
                  SolveFunction = Join(Tmp) '//Space default
                  Exit Function
               End If
            ElseIf UBound(Args) = 2 Then
               Tmp = Split(Args(0), Args(2))
               If UBound(Tmp) >= Int(Args(1)) - 1 Then
                  Tmp(Int(Args(1)) - 1) = Chr(186) & "BURN"
                  Tmp = Filter(Tmp, Chr(186) & "BURN", False)
                  SolveFunction = Join(Tmp, Args(2))
                  Exit Function
               End If
            End If
            
         Case "do"
            Tmp = Args(0)
            Tmp = Replace(Tmp, "@", "%")
            Tmp = Replace(Tmp, "[", "(")
            Tmp = Replace(Tmp, "]", ")")
            Tmp = Replace(Tmp, ":", ",")
            SolveFunction = Me.ParseFunctions(Tmp)
         '//Returns the amount a string appears in a string.
         Case "count"
            If UBound(Args) = 1 Then
               SolveFunction = UBound(Split(Args(0), Args(1)))
               If SolveFunction = -1 Then SolveFunction = 0
            End If
         '//Mimic function
         Case "instr"
            If UBound(Args) = 2 Then
               SolveFunction = InStr(Args(0), Args(1), Args(2))
            ElseIf UBound(Args) = 1 Then
               SolveFunction = InStr(Args(0), Args(1))
            End If
         Case "chr" If UBound(args) = 0 Then SolveFunction = Chr(Me.SecureEval(Args(0)))
         Case "math" If UBound(args) = 0 Then SolveFunction = Me.SecureEval(Args(0))
         '//Removes @lordaeron @useast #2 etc.
         Case "no@"
            Dim PUser
            PUser = Args(0)
            If Left(PUser, 1) = "*" Then PUser = Mid(PUser, 2)
            If InStr(PUser, "#") Then PUser = Mid(PUser, 1, InStr(PUser & "#", "#")-1)
            If InStr(PUser, "@") Then PUser = Mid(PUser, 1, InStr(PUser & "@", "@")-1)
            SolveFunction = PUser
         Case "getgid" '//MIMICS STEALTHBOT'S GetInternalDataByUsername
            If UBound(Args) = 1 Then
               SolveFunction = GetInternalDataByUsername(Args(0), Args(1))
            End If   
         Case "die" '// DIE
            SolveFunction = RStr
         Case "seco" '// FROM TIME IN SECONDS
            SolveFunction = me.SecondsToOrgin(Args(0))
         Case "secf" '// FROM TIME IN SECONDS
            SolveFunction = me.SecondsToTime(Args(0))
         Case "gethttp" '// URL,[SHOW RESPONSE] = True,[CATCH]=False
            'If UBound(Args) >= 1 Then
            If scinet.StillExecuting Then
               SolveFunction = "Error"
            End If
            Tmp = scinet.GetURL(Args(0))
            If Len(Tmp < 255) Then
               SolveFunction = Tmp
            Else
               SolveFunction = "Error"
            End If
         
         '//LIST FUNCTIONS
         Case "listadd"
            If UBound(Args) >= 1 Then
               Tmp = GetConfigEntry("lists", Me.SecureEval(Args(0)), Me.DL_Path)
               Tmp2 = Replace(Me.SecureEval(Args(1)), "*", "|ASTRIX|")
               WriteConfigEntry "lists", Me.SecureEval(Args(0)), Tmp & "*" & Tmp2, Me.DL_Path
            End If
            If UBound(Args) = 2 Then
               If Lcase(Args(2)) = "true" Then SolveFunction = UBound(Split(Tmp & "*", "*"))
            Else
               SolveFunction = ""
            End If
         Case "listdel"
            If UBound(Args) >= 1 Then
               Tmp = Split(GetConfigEntry("lists", Me.SecureEval(Args(0)), Me.DL_Path), "*")
               If UBound(Tmp) >= Int(Args(1)) AND Int(Args(1)) > 0 Then
                  Tmp(Int(Args(1))) = Chr(186) & "BURN"
                  Tmp = Filter(Tmp, Chr(186) & "BURN", False)
                  WriteConfigEntry "lists", Me.SecureEval(Args(0)), Join(Tmp, "*"), Me.DL_Path
                  Exit Function
               End If
            End If
         Case "listclear"
            WriteConfigEntry "lists", Me.SecureEval(Args(0)), "", Me.DL_Path
         Case "inlist"
            If UBound(Args) > 0 Then
               Tmp = Split(GetConfigEntry("lists", Me.SecureEval(Args(0)), Me.DL_Path), "*")
               SolveFunction = 0
               For I = 0 To UBound(Tmp)
                  If Lcase(Args(1)) = Lcase(Tmp(I)) Then
                     SolveFunction = I
                     Exit For
                  End If
               Next
            End If
         Case "listout"
            Tmp2 = " ##: "
            If UBound(Args) > 0 Then
               Tmp2 = Args(1)
            End If
            I = 0
            For Each Item in Split(GetConfigEntry("lists", Me.SecureEval(Args(0)), Me.DL_Path), "*")
               If Item <> "" Then
                  I = I + 1
                  If Tmp = "" And Instr(Tmp2, "#") = 0 Then
                     Tmp = Item
                  Else
                     Dim Seperator
                     'Addchat VByellow, Seperator & "||" & I
                     Seperator = Replace(Tmp2, "##", I)
                     Seperator = Replace(Seperator, "#R", me.Roman(I))
                     Seperator = Replace(Seperator, "#A", me.Alpha(I))
                     Tmp = Tmp & Seperator & Item
                  End If
               End If
            Next
            Tmp = Replace(LTrim(Tmp), "|ASTRIX|", "*")
            SolveFunction = Tmp
            
         Case "listitem"
            If UBound(Args) >= 1 Then
               Tmp = Split(GetConfigEntry("lists", Me.SecureEval(Args(0)), Me.DL_Path), "*")
               If UBound(Tmp) >= Int(Args(1)) Then SolveFunction = Tmp(Int(Args(1)))
            End If
         Case "getdef"
            SolveFunction = GetConfigEntry("def", Me.SecureEval(Args(0)), BotPath & "definitions.ini")
         Case "setdef"
            If UBound(Args) = 1 Then
               WriteConfigEntry "def", Me.SecureEval(Args(0)), Me.SecureEval(Args(1)), BotPath & "definitions.ini"
            End If
         Case "var", "getdl"
            If UBound(Args) = 0 Then
               SolveFunction = GetConfigEntry("main", Me.SecureEval(Args(0)), Me.DL_Path)
            ElseIf UBound(Args) = 1 Then
               SolveFunction = GetConfigEntry(Me.SecureEval(Args(1)), Me.SecureEval(Args(0)), Me.DL_Path)
            End If
         Case "setvar", "setdl"
            If UBound(Args) = 1 Then
               WriteConfigEntry "main", Me.SecureEval(Args(0)), Me.SecureEval(Args(1)), Me.DL_Path
            ElseIf UBound(Args) = 2 Then
               WriteConfigEntry Me.SecureEval(Args(2)), Me.SecureEval(Args(0)), Me.SecureEval(Args(1)), Me.DL_Path
            End If
         Case "withvar", "withdl" '// DLNAME, OPERATION, [RETURN RESULT] = False, [LOCATION] = main
            If UBound(Args) >= 1 Then
               Tmp = GetConfigEntry("main", Me.SecureEval(Args(0)), Me.DL_Path)
               If IsNumeric(Args(1)) Then
                  Tmp = Me.SecureEval(Tmp & "+" & Int(Args(1)))
               '//Multiply
               ElseIf IsNumeric(Replace(Args(1), "*", "")) Then
                  Tmp = Me.SecureEval(Tmp & "*" & Replace(Args(1), "*", ""))
               '//Division
               ElseIf IsNumeric(Replace(Args(1), "/", "")) Then
                  Tmp = Me.SecureEval(Tmp & "/" & Replace(Args(1), "/", ""))
               '//Power
               ElseIf IsNumeric(Replace(Args(1), "^", "")) Then
                  Tmp = Me.SecureEval(Tmp & "^" & Replace(Args(1), "^", ""))
               '//Modulo Division
               ElseIf IsNumeric(Replace(Args(1), "MOD", "")) Then
                  Tmp = Me.SecureEval(Tmp & "MOD" & Replace(Args(1), "MOD", ""))
               '//Append it
               ElseIf Left(Args(1), 1) = "&" Then
                  Tmp = Me.SecureEval(Tmp & Mid(Args(1), 2))
               ElseIf Right(Args(1), 1) = "&" Then
                  Tmp = Me.SecureEval(Mid(Args(1), 1, Len(Args(1)) - 1) & Tmp)
               '//Set it
               Else
                  Tmp = Me.SecureEval(Args(1))
               End If
            End If
            '//Write the solution.
            If UBound(Args) = 3 Then
               WriteConfigEntry Args(3), Me.SecureEval(Args(0)), Tmp, Me.DL_Path
            Else
               WriteConfigEntry "main", Me.SecureEval(Args(0)), Tmp, Me.DL_Path
            End If
            '//If true is added to the arguement.
            If UBound(Args) = 2 Then
               If Lcase(Args(2)) = "true" Then
                  SolveFunction = Tmp
               End If
            End If
            REM If Me.Datalist.Exists(Args(0)) Then
               REM Me.Datalist.Item(Args(0)) = Me.SecureEval(Args(1))
            REM Else
               REM Me.Datalist.Add Args(0), Me.SecureEval(Args(1))
            REM End If
      End Select
 
      '//Check registered functions
      If FuncList.Exists(Name) Then
         For I = 0 To FuncList.Item(Name)(1) - 1
            If UBound(Args) >= I Then
               ArgList = ArgList & ", """ & Args(I) & """"
            Else
               ArgList = ", """"" & ArgList
            End If
         Next
         'ArgList = "(" & Name & ArgList & ")"
         ArgList = "(" & Mid(ArgList, 3) & ")"
         ExecuteGlobal "ccx.ReturnSol = " & FuncList.Item(Name)(0) & ArgList
         SolveFunction = Me.ReturnSol
         Exit Function
      End If
      
         'Addchat VByellow, "Solve Function end - " & SolveFunction
   End Function
 
   '//Returns the length of the command, if it is one.
   Public Function IsFunction(Text, Priority)
 
      'Addchat VByellow, Priority & ") IsFunction Start: " & Text
      
      Dim TmpList, Tmp
      IsFunction = 0
      If Instr(Text, "(") < 2 Then Exit Function
      Text = LCase(Mid(Text, 2, Instr(Text, "(") - 2))
      Priority = Int(Priority)
      '//List the built-in functions here.
      'Remember to Put things like "abcbla" infront of "abc"
      If Priority = 1 Then
         TmpList = Array("seco", "secf", "round", "getgid", "count", "xitem", "item", _
         "if", "ifnot", "switch", "for", "rand", "mid", "instr", "chr", "no@", "getdl", "var", "math", _
         "do", "listitem", "listout", "inlist", "getdef")
         IsFunction = 0
         For Each Func in TmpList
            If Text = Func Then
               IsFunction = Len(Func) + 1
               Exit For
            End If
         Next
      End If
 
      If Priority = 2 Then
         TmpList = Array("die", "wait", "makecc", "pfunc", "setdl", "setvar", "withdl", "withvar", _
         "listclear", "listadd", "listdel", "gethttp", "setdef")
         For Each Func in TmpList
            Tmp = InStr(1, Text, "%" & Func, 1)
            If Text = Func Then
               IsFunction = Len(Func) + 1
               Exit For
            End If
         Next
      End If
      '//Check Registered functions:
      For Each Func in Me.FuncList
         If Text = Lcase(Func) Then
            If Me.FuncList.Item(Func)(2) = Priority Then
               IsFunction = Len(Func) + 1
               Exit For
            End If
         End If
      Next
      
      'Addchat VBYellow, "IsFunction End [" & IsFunction & "]"
      
   End Function
 
   '//A more forgiving/secure wraper for the Eval function
   Public Function SecureEval(Text)

      If Text = "" Then Exit Function
      '//Unparsed remnants should return null.
      If Left(Text, 1) = "%" Then Exit Function
      Tmp = Replace(Text, "mod", "", 1, -1, 1)
      If UCase(Tmp) = LCase(Tmp) Then
         On Error Resume Next
         SecureEval = Eval(Text)
         If Err.Number = 1032 Then
            SecureEval = Text
         ElseIf Err.Number Then
            Addchat VBred, "CC Error: Error occured when parsing Eval: " & Err.Number
         End If
         On Error Goto 0
      ElseIf InStr(Text, "=") Then
         Tmp = Split(Text, "=")
         Tmp(0) = """" & LCase(Trim(Tmp(0))) & """"
         Tmp(1) = """" & LCase(Trim(Tmp(1))) & """"
         SecureEval = Eval(Tmp(0) & "=" & Tmp(1))
      ElseIf InStr(Text, "<>") Then
         Tmp = Split(Text, "<>")
         Tmp(0) = """" & LCase(Trim(Tmp(0))) & """"
         Tmp(1) = """" & LCase(Trim(Tmp(1))) & """"
         SecureEval = Eval(Tmp(0) & "<>" & Tmp(1))
      '//Alias
      ElseIf InStr(Text, "!=") Then
         Tmp = Split(Text, "!=")
         Tmp(0) = """" & LCase(Trim(Tmp(0))) & """"
         Tmp(1) = """" & LCase(Trim(Tmp(1))) & """"
         SecureEval = Eval(Tmp(0) & "<>" & Tmp(1))
      Else
         SecureEval = Text
      End If
   End Function
 
   '//Written By Ronin ; Edited by Snap.
   Public Function FindCommands(What, Access, Flags)
 
      FindCommands = ""
      Dim Keys
      Keys = Me.CC.Keys
      If What <> "" Then Keys = Filter(Keys, What, True)
      
      For Each Key in Keys
         If Me.HasAccess(Key, Access, Flags) Then
            FindCommands = FindCommands & Key & ", "
         End If
      Next
 
      If Right(FindCommands, 2) = ", " Then FindCommands = Left(FindCommands, Len(FindCommands) - 2)
   End Function
 
   '//Returns True/False
   Public Function HasAccess(MyCommand, MyAccess, MyFlags)
 
      If Not Me.CC.Exists(MyCommand) Then Exit Function
      Dim ReqFlags, ReqAccess
      MyFlags = UCase(MyFlags)
      ReqFlags = UCase(Me.CC.Item(MyCommand).Flags)
      ReqAccess = Int(Me.CC.Item(MyCommand).Access)
      
      If MyAccess >= ReqAccess OR ReqAccess = 0 Then
         HasAccess = True
      Else
         HasAccess = False
         Exit Function
      End If
      For I = 1 to Len(ReqFlags)
         If InStr(MyFlags, Mid(ReqFlags, I, 1)) = 0 Then
            HasAccess = False
            Exit Function
         End If
      Next
   End Function
   
   '//Time related function
   '//Returns the time/date of Seconds seconds ago.
   Public Function SecondsToOrgin(Seconds)
   
      SecondsToOrgin = DateAdd("s", -Seconds, Now)
      If FormatDateTime(SecondsToOrgin, vbShortDate) = FormatDateTime(Date, vbShortDate) Then
         SecondsToOrgin = DateAdd("s", -Seconds, Time)
      End If
   End Function
   
   '//Turns seconds into something like: "6 Day(s) 23:01:52"
   Public Function SecondsToTime(Seconds)
   
      Dim Days, Hours, Minutes
      Days = Int(Seconds / 86400)
      Seconds = Seconds MOD 86400
      Hours = AddZero(Int(Seconds / 3600))
      Seconds = Seconds MOD 3600
      Minutes = AddZero(Int(Seconds / 60))
      Seconds = AddZero(Seconds MOD 60)
      
      If Days Then
         SecondsToTime = Days & " Day(s) " & Hours & ":" & Minutes & ":" & Seconds
      ElseIf Hours Then
         SecondsToTime = Hours & ":" & Minutes & ":" & Seconds
      Else
         SecondsToTime = Minutes & ":" & Seconds
      End If
   End Function
   
   Private Function AddZero(Number)
   
      If Len(Number) = 1 Then
         AddZero = "0" & Number
      Else
         AddZero = Number
      End If
   End Function
 
   '//Public Use Functions   
   Public Sub RegisterFunction(Name, CallBack, Args, Priority)
 
   '//psSC.Procedures(Name).NumArgs
   '//GetBotVersion
      If FuncList.Exists(Name) Then
         Addchat VBred, "CCX Error: Duplicate function registered!: " & Name
      Else
         FuncList.Add Name, Array(CallBack, Args, Priority)
      End If
   End Sub
 
   Public Function UnregisterFunction(Name)
 
      If FuncList.Exists(Name) Then
         FuncList.Remove(Name)
         UnregisterFunction = True
      Else
         UnregisterFunction = False
      End If
   End Function
   
   
   
   '==WRITE ME YOURSELF SNAP!!
       '**************************************
    ' Name: Roman Numerals
    ' Description:This converts a number to 
    '     roman numerals.
    ' By: Sock
    '
    ' Inputs:The number you want to format.
    '
    ' Returns:The roman numeral for that num
    '     er.
    '
    'This code is copyrighted and has    ' limited warranties.Please see http://w
    '     ww.Planet-Source-Code.com/vb/scripts/Sho
    '     wCode.asp?txtCodeId=7078&lngWId=4    'for details.    '**************************************
    
    'example usage:
    'response.write "2001: " & roman(2001)
    'or msgbox "2001: " & roman(2001)
    function roman(number)
    Dim v, w, x, y
    Dim str1
    Dim roman_unit
    Dim roman_tens
    Dim roman_hund
    Dim roman_thou
    roman_unit = Array("","I","II","III","IV","V","VI","VII","VIII","IX")
    roman_tens = Array("","X","XX","XXX","XL","L","LX","LXX","LXXX","XC")
    roman_hund = Array("","C","CC","CCC","CD","D","DC","DCC","DCCC","CM")
    roman_thou = Array("","M","MM","MMM","MMMM","MMMMM")
    v = 0
    w = 0
    x = 0
    y = 0
    v = ((number - (number mod 1000)) / 1000)
    number = (number mod 1000)
    w = ((number - (number mod 100)) / 100)
    number = (number mod 100)
    x = ((number - (number mod 10)) / 10)
    y = (number mod 10)
    roman = roman_thou(v) & roman_hund(w) & roman_tens(x) & roman_unit(y)
    End function
   
   Public Function Alpha(ByVal Number)
   
      If Number > 0 Then
         Number = Number - 1
         Alpha = Chr((Number MOD 26) + 65)
         If Int(Number / 26) MOD 2 = 1 Then
            Alpha = Lcase(Alpha)
         End If
      End If
   End Function
   
   
   
End Class